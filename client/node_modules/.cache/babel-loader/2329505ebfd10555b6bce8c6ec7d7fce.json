{"ast":null,"code":"'use strict'; // this[BUFFER] is the remainder of a chunk if we're waiting for\n// the full 512 bytes of a header to come in.  We will Buffer.concat()\n// it to the next write(), which is a mem copy, but a small one.\n//\n// this[QUEUE] is a Yallist of entries that haven't been emitted\n// yet this can only get filled up if the user keeps write()ing after\n// a write() returns false, or does a write() with more than one entry\n//\n// We don't buffer chunks, we always parse them and either create an\n// entry, or push it into the active entry.  The ReadEntry class knows\n// to throw data away if .ignore=true\n//\n// Shift entry off the buffer when it emits 'end', and emit 'entry' for\n// the next one in the list.\n//\n// At any time, we're pushing body chunks into the entry at WRITEENTRY,\n// and waiting for 'end' on the entry at READENTRY\n//\n// ignored entries get .resume() called on them straight away\n\nvar _classCallCheck = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar warner = require('./warn-mixin.js');\n\nvar Header = require('./header.js');\n\nvar EE = require('events');\n\nvar Yallist = require('yallist');\n\nvar maxMetaEntrySize = 1024 * 1024;\n\nvar Entry = require('./read-entry.js');\n\nvar Pax = require('./pax.js');\n\nvar zlib = require('minizlib');\n\nvar gzipHeader = Buffer.from([0x1f, 0x8b]);\nvar STATE = Symbol('state');\nvar WRITEENTRY = Symbol('writeEntry');\nvar READENTRY = Symbol('readEntry');\nvar NEXTENTRY = Symbol('nextEntry');\nvar PROCESSENTRY = Symbol('processEntry');\nvar EX = Symbol('extendedHeader');\nvar GEX = Symbol('globalExtendedHeader');\nvar META = Symbol('meta');\nvar EMITMETA = Symbol('emitMeta');\nvar BUFFER = Symbol('buffer');\nvar QUEUE = Symbol('queue');\nvar ENDED = Symbol('ended');\nvar EMITTEDEND = Symbol('emittedEnd');\nvar EMIT = Symbol('emit');\nvar UNZIP = Symbol('unzip');\nvar CONSUMECHUNK = Symbol('consumeChunk');\nvar CONSUMECHUNKSUB = Symbol('consumeChunkSub');\nvar CONSUMEBODY = Symbol('consumeBody');\nvar CONSUMEMETA = Symbol('consumeMeta');\nvar CONSUMEHEADER = Symbol('consumeHeader');\nvar CONSUMING = Symbol('consuming');\nvar BUFFERCONCAT = Symbol('bufferConcat');\nvar MAYBEEND = Symbol('maybeEnd');\nvar WRITING = Symbol('writing');\nvar ABORTED = Symbol('aborted');\nvar DONE = Symbol('onDone');\nvar SAW_VALID_ENTRY = Symbol('sawValidEntry');\nvar SAW_NULL_BLOCK = Symbol('sawNullBlock');\nvar SAW_EOF = Symbol('sawEOF');\n\nvar noop = function noop(_) {\n  return true;\n};\n\nmodule.exports = warner( /*#__PURE__*/function (_EE) {\n  _inherits(Parser, _EE);\n\n  var _super = _createSuper(Parser);\n\n  function Parser(opt) {\n    var _this;\n\n    _classCallCheck(this, Parser);\n\n    opt = opt || {};\n    _this = _super.call(this, opt);\n    _this.file = opt.file || ''; // set to boolean false when an entry starts.  1024 bytes of \\0\n    // is technically a valid tarball, albeit a boring one.\n\n    _this[SAW_VALID_ENTRY] = null; // these BADARCHIVE errors can't be detected early. listen on DONE.\n\n    _this.on(DONE, function (_) {\n      if (_this[STATE] === 'begin' || _this[SAW_VALID_ENTRY] === false) {\n        // either less than 1 block of data, or all entries were invalid.\n        // Either way, probably not even a tarball.\n        _this.warn('TAR_BAD_ARCHIVE', 'Unrecognized archive format');\n      }\n    });\n\n    if (opt.ondone) _this.on(DONE, opt.ondone);else {\n      _this.on(DONE, function (_) {\n        _this.emit('prefinish');\n\n        _this.emit('finish');\n\n        _this.emit('end');\n\n        _this.emit('close');\n      });\n    }\n    _this.strict = !!opt.strict;\n    _this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize;\n    _this.filter = typeof opt.filter === 'function' ? opt.filter : noop; // have to set this so that streams are ok piping into it\n\n    _this.writable = true;\n    _this.readable = false;\n    _this[QUEUE] = new Yallist();\n    _this[BUFFER] = null;\n    _this[READENTRY] = null;\n    _this[WRITEENTRY] = null;\n    _this[STATE] = 'begin';\n    _this[META] = '';\n    _this[EX] = null;\n    _this[GEX] = null;\n    _this[ENDED] = false;\n    _this[UNZIP] = null;\n    _this[ABORTED] = false;\n    _this[SAW_NULL_BLOCK] = false;\n    _this[SAW_EOF] = false;\n    if (typeof opt.onwarn === 'function') _this.on('warn', opt.onwarn);\n    if (typeof opt.onentry === 'function') _this.on('entry', opt.onentry);\n    return _this;\n  }\n\n  _createClass(Parser, [{\n    key: CONSUMEHEADER,\n    value: function value(chunk, position) {\n      var _this2 = this;\n\n      if (this[SAW_VALID_ENTRY] === null) this[SAW_VALID_ENTRY] = false;\n      var header;\n\n      try {\n        header = new Header(chunk, position, this[EX], this[GEX]);\n      } catch (er) {\n        return this.warn('TAR_ENTRY_INVALID', er);\n      }\n\n      if (header.nullBlock) {\n        if (this[SAW_NULL_BLOCK]) {\n          this[SAW_EOF] = true; // ending an archive with no entries.  pointless, but legal.\n\n          if (this[STATE] === 'begin') this[STATE] = 'header';\n          this[EMIT]('eof');\n        } else {\n          this[SAW_NULL_BLOCK] = true;\n          this[EMIT]('nullBlock');\n        }\n      } else {\n        this[SAW_NULL_BLOCK] = false;\n        if (!header.cksumValid) this.warn('TAR_ENTRY_INVALID', 'checksum failure', {\n          header: header\n        });else if (!header.path) this.warn('TAR_ENTRY_INVALID', 'path is required', {\n          header: header\n        });else {\n          var type = header.type;\n          if (/^(Symbolic)?Link$/.test(type) && !header.linkpath) this.warn('TAR_ENTRY_INVALID', 'linkpath required', {\n            header: header\n          });else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath) this.warn('TAR_ENTRY_INVALID', 'linkpath forbidden', {\n            header: header\n          });else {\n            var entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX]); // we do this for meta & ignored entries as well, because they\n            // are still valid tar, or else we wouldn't know to ignore them\n\n            if (!this[SAW_VALID_ENTRY]) {\n              if (entry.remain) {\n                // this might be the one!\n                var onend = function onend() {\n                  if (!entry.invalid) _this2[SAW_VALID_ENTRY] = true;\n                };\n\n                entry.on('end', onend);\n              } else this[SAW_VALID_ENTRY] = true;\n            }\n\n            if (entry.meta) {\n              if (entry.size > this.maxMetaEntrySize) {\n                entry.ignore = true;\n                this[EMIT]('ignoredEntry', entry);\n                this[STATE] = 'ignore';\n                entry.resume();\n              } else if (entry.size > 0) {\n                this[META] = '';\n                entry.on('data', function (c) {\n                  return _this2[META] += c;\n                });\n                this[STATE] = 'meta';\n              }\n            } else {\n              this[EX] = null;\n              entry.ignore = entry.ignore || !this.filter(entry.path, entry);\n\n              if (entry.ignore) {\n                // probably valid, just not something we care about\n                this[EMIT]('ignoredEntry', entry);\n                this[STATE] = entry.remain ? 'ignore' : 'header';\n                entry.resume();\n              } else {\n                if (entry.remain) this[STATE] = 'body';else {\n                  this[STATE] = 'header';\n                  entry.end();\n                }\n\n                if (!this[READENTRY]) {\n                  this[QUEUE].push(entry);\n                  this[NEXTENTRY]();\n                } else this[QUEUE].push(entry);\n              }\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: PROCESSENTRY,\n    value: function value(entry) {\n      var _this3 = this;\n\n      var go = true;\n\n      if (!entry) {\n        this[READENTRY] = null;\n        go = false;\n      } else if (Array.isArray(entry)) this.emit.apply(this, entry);else {\n        this[READENTRY] = entry;\n        this.emit('entry', entry);\n\n        if (!entry.emittedEnd) {\n          entry.on('end', function (_) {\n            return _this3[NEXTENTRY]();\n          });\n          go = false;\n        }\n      }\n\n      return go;\n    }\n  }, {\n    key: NEXTENTRY,\n    value: function value() {\n      var _this4 = this;\n\n      do {} while (this[PROCESSENTRY](this[QUEUE].shift()));\n\n      if (!this[QUEUE].length) {\n        // At this point, there's nothing in the queue, but we may have an\n        // entry which is being consumed (readEntry).\n        // If we don't, then we definitely can handle more data.\n        // If we do, and either it's flowing, or it has never had any data\n        // written to it, then it needs more.\n        // The only other possibility is that it has returned false from a\n        // write() call, so we wait for the next drain to continue.\n        var re = this[READENTRY];\n        var drainNow = !re || re.flowing || re.size === re.remain;\n\n        if (drainNow) {\n          if (!this[WRITING]) this.emit('drain');\n        } else re.once('drain', function (_) {\n          return _this4.emit('drain');\n        });\n      }\n    }\n  }, {\n    key: CONSUMEBODY,\n    value: function value(chunk, position) {\n      // write up to but no  more than writeEntry.blockRemain\n      var entry = this[WRITEENTRY];\n      var br = entry.blockRemain;\n      var c = br >= chunk.length && position === 0 ? chunk : chunk.slice(position, position + br);\n      entry.write(c);\n\n      if (!entry.blockRemain) {\n        this[STATE] = 'header';\n        this[WRITEENTRY] = null;\n        entry.end();\n      }\n\n      return c.length;\n    }\n  }, {\n    key: CONSUMEMETA,\n    value: function value(chunk, position) {\n      var entry = this[WRITEENTRY];\n      var ret = this[CONSUMEBODY](chunk, position); // if we finished, then the entry is reset\n\n      if (!this[WRITEENTRY]) this[EMITMETA](entry);\n      return ret;\n    }\n  }, {\n    key: EMIT,\n    value: function value(ev, data, extra) {\n      if (!this[QUEUE].length && !this[READENTRY]) this.emit(ev, data, extra);else this[QUEUE].push([ev, data, extra]);\n    }\n  }, {\n    key: EMITMETA,\n    value: function value(entry) {\n      this[EMIT]('meta', this[META]);\n\n      switch (entry.type) {\n        case 'ExtendedHeader':\n        case 'OldExtendedHeader':\n          this[EX] = Pax.parse(this[META], this[EX], false);\n          break;\n\n        case 'GlobalExtendedHeader':\n          this[GEX] = Pax.parse(this[META], this[GEX], true);\n          break;\n\n        case 'NextFileHasLongPath':\n        case 'OldGnuLongPath':\n          this[EX] = this[EX] || Object.create(null);\n          this[EX].path = this[META].replace(/\\0.*/, '');\n          break;\n\n        case 'NextFileHasLongLinkpath':\n          this[EX] = this[EX] || Object.create(null);\n          this[EX].linkpath = this[META].replace(/\\0.*/, '');\n          break;\n\n        /* istanbul ignore next */\n\n        default:\n          throw new Error('unknown meta: ' + entry.type);\n      }\n    }\n  }, {\n    key: \"abort\",\n    value: function abort(error) {\n      this[ABORTED] = true;\n      this.emit('abort', error); // always throws, even in non-strict mode\n\n      this.warn('TAR_ABORT', error, {\n        recoverable: false\n      });\n    }\n  }, {\n    key: \"write\",\n    value: function write(chunk) {\n      var _this5 = this;\n\n      if (this[ABORTED]) return; // first write, might be gzipped\n\n      if (this[UNZIP] === null && chunk) {\n        if (this[BUFFER]) {\n          chunk = Buffer.concat([this[BUFFER], chunk]);\n          this[BUFFER] = null;\n        }\n\n        if (chunk.length < gzipHeader.length) {\n          this[BUFFER] = chunk;\n          return true;\n        }\n\n        for (var i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) {\n          if (chunk[i] !== gzipHeader[i]) this[UNZIP] = false;\n        }\n\n        if (this[UNZIP] === null) {\n          var ended = this[ENDED];\n          this[ENDED] = false;\n          this[UNZIP] = new zlib.Unzip();\n          this[UNZIP].on('data', function (chunk) {\n            return _this5[CONSUMECHUNK](chunk);\n          });\n          this[UNZIP].on('error', function (er) {\n            return _this5.abort(er);\n          });\n          this[UNZIP].on('end', function (_) {\n            _this5[ENDED] = true;\n\n            _this5[CONSUMECHUNK]();\n          });\n          this[WRITING] = true;\n\n          var _ret = this[UNZIP][ended ? 'end' : 'write'](chunk);\n\n          this[WRITING] = false;\n          return _ret;\n        }\n      }\n\n      this[WRITING] = true;\n      if (this[UNZIP]) this[UNZIP].write(chunk);else this[CONSUMECHUNK](chunk);\n      this[WRITING] = false; // return false if there's a queue, or if the current entry isn't flowing\n\n      var ret = this[QUEUE].length ? false : this[READENTRY] ? this[READENTRY].flowing : true; // if we have no queue, then that means a clogged READENTRY\n\n      if (!ret && !this[QUEUE].length) this[READENTRY].once('drain', function (_) {\n        return _this5.emit('drain');\n      });\n      return ret;\n    }\n  }, {\n    key: BUFFERCONCAT,\n    value: function value(c) {\n      if (c && !this[ABORTED]) this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c;\n    }\n  }, {\n    key: MAYBEEND,\n    value: function value() {\n      if (this[ENDED] && !this[EMITTEDEND] && !this[ABORTED] && !this[CONSUMING]) {\n        this[EMITTEDEND] = true;\n        var entry = this[WRITEENTRY];\n\n        if (entry && entry.blockRemain) {\n          // truncated, likely a damaged file\n          var have = this[BUFFER] ? this[BUFFER].length : 0;\n          this.warn('TAR_BAD_ARCHIVE', \"Truncated input (needed \".concat(entry.blockRemain, \" more bytes, only \").concat(have, \" available)\"), {\n            entry: entry\n          });\n          if (this[BUFFER]) entry.write(this[BUFFER]);\n          entry.end();\n        }\n\n        this[EMIT](DONE);\n      }\n    }\n  }, {\n    key: CONSUMECHUNK,\n    value: function value(chunk) {\n      if (this[CONSUMING]) this[BUFFERCONCAT](chunk);else if (!chunk && !this[BUFFER]) this[MAYBEEND]();else {\n        this[CONSUMING] = true;\n\n        if (this[BUFFER]) {\n          this[BUFFERCONCAT](chunk);\n          var c = this[BUFFER];\n          this[BUFFER] = null;\n          this[CONSUMECHUNKSUB](c);\n        } else this[CONSUMECHUNKSUB](chunk);\n\n        while (this[BUFFER] && this[BUFFER].length >= 512 && !this[ABORTED] && !this[SAW_EOF]) {\n          var _c = this[BUFFER];\n          this[BUFFER] = null;\n          this[CONSUMECHUNKSUB](_c);\n        }\n\n        this[CONSUMING] = false;\n      }\n      if (!this[BUFFER] || this[ENDED]) this[MAYBEEND]();\n    }\n  }, {\n    key: CONSUMECHUNKSUB,\n    value: function value(chunk) {\n      // we know that we are in CONSUMING mode, so anything written goes into\n      // the buffer.  Advance the position and put any remainder in the buffer.\n      var position = 0;\n      var length = chunk.length;\n\n      while (position + 512 <= length && !this[ABORTED] && !this[SAW_EOF]) {\n        switch (this[STATE]) {\n          case 'begin':\n          case 'header':\n            this[CONSUMEHEADER](chunk, position);\n            position += 512;\n            break;\n\n          case 'ignore':\n          case 'body':\n            position += this[CONSUMEBODY](chunk, position);\n            break;\n\n          case 'meta':\n            position += this[CONSUMEMETA](chunk, position);\n            break;\n\n          /* istanbul ignore next */\n\n          default:\n            throw new Error('invalid state: ' + this[STATE]);\n        }\n      }\n\n      if (position < length) {\n        if (this[BUFFER]) this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]]);else this[BUFFER] = chunk.slice(position);\n      }\n    }\n  }, {\n    key: \"end\",\n    value: function end(chunk) {\n      if (!this[ABORTED]) {\n        if (this[UNZIP]) this[UNZIP].end(chunk);else {\n          this[ENDED] = true;\n          this.write(chunk);\n        }\n      }\n    }\n  }]);\n\n  return Parser;\n}(EE));","map":{"version":3,"sources":["/Users/austenhughes/The-Baffoonery/node_modules/tar/lib/parse.js"],"names":["warner","require","Header","EE","Yallist","maxMetaEntrySize","Entry","Pax","zlib","gzipHeader","Buffer","from","STATE","Symbol","WRITEENTRY","READENTRY","NEXTENTRY","PROCESSENTRY","EX","GEX","META","EMITMETA","BUFFER","QUEUE","ENDED","EMITTEDEND","EMIT","UNZIP","CONSUMECHUNK","CONSUMECHUNKSUB","CONSUMEBODY","CONSUMEMETA","CONSUMEHEADER","CONSUMING","BUFFERCONCAT","MAYBEEND","WRITING","ABORTED","DONE","SAW_VALID_ENTRY","SAW_NULL_BLOCK","SAW_EOF","noop","_","module","exports","opt","file","on","warn","ondone","emit","strict","filter","writable","readable","onwarn","onentry","chunk","position","header","er","nullBlock","cksumValid","path","type","test","linkpath","entry","remain","onend","invalid","meta","size","ignore","resume","c","end","push","go","Array","isArray","apply","emittedEnd","shift","length","re","drainNow","flowing","once","br","blockRemain","slice","write","ret","ev","data","extra","parse","Object","create","replace","Error","error","recoverable","concat","i","ended","Unzip","abort","have"],"mappings":"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","sourcesContent":["'use strict'\n\n// this[BUFFER] is the remainder of a chunk if we're waiting for\n// the full 512 bytes of a header to come in.  We will Buffer.concat()\n// it to the next write(), which is a mem copy, but a small one.\n//\n// this[QUEUE] is a Yallist of entries that haven't been emitted\n// yet this can only get filled up if the user keeps write()ing after\n// a write() returns false, or does a write() with more than one entry\n//\n// We don't buffer chunks, we always parse them and either create an\n// entry, or push it into the active entry.  The ReadEntry class knows\n// to throw data away if .ignore=true\n//\n// Shift entry off the buffer when it emits 'end', and emit 'entry' for\n// the next one in the list.\n//\n// At any time, we're pushing body chunks into the entry at WRITEENTRY,\n// and waiting for 'end' on the entry at READENTRY\n//\n// ignored entries get .resume() called on them straight away\n\nconst warner = require('./warn-mixin.js')\nconst Header = require('./header.js')\nconst EE = require('events')\nconst Yallist = require('yallist')\nconst maxMetaEntrySize = 1024 * 1024\nconst Entry = require('./read-entry.js')\nconst Pax = require('./pax.js')\nconst zlib = require('minizlib')\n\nconst gzipHeader = Buffer.from([0x1f, 0x8b])\nconst STATE = Symbol('state')\nconst WRITEENTRY = Symbol('writeEntry')\nconst READENTRY = Symbol('readEntry')\nconst NEXTENTRY = Symbol('nextEntry')\nconst PROCESSENTRY = Symbol('processEntry')\nconst EX = Symbol('extendedHeader')\nconst GEX = Symbol('globalExtendedHeader')\nconst META = Symbol('meta')\nconst EMITMETA = Symbol('emitMeta')\nconst BUFFER = Symbol('buffer')\nconst QUEUE = Symbol('queue')\nconst ENDED = Symbol('ended')\nconst EMITTEDEND = Symbol('emittedEnd')\nconst EMIT = Symbol('emit')\nconst UNZIP = Symbol('unzip')\nconst CONSUMECHUNK = Symbol('consumeChunk')\nconst CONSUMECHUNKSUB = Symbol('consumeChunkSub')\nconst CONSUMEBODY = Symbol('consumeBody')\nconst CONSUMEMETA = Symbol('consumeMeta')\nconst CONSUMEHEADER = Symbol('consumeHeader')\nconst CONSUMING = Symbol('consuming')\nconst BUFFERCONCAT = Symbol('bufferConcat')\nconst MAYBEEND = Symbol('maybeEnd')\nconst WRITING = Symbol('writing')\nconst ABORTED = Symbol('aborted')\nconst DONE = Symbol('onDone')\nconst SAW_VALID_ENTRY = Symbol('sawValidEntry')\nconst SAW_NULL_BLOCK = Symbol('sawNullBlock')\nconst SAW_EOF = Symbol('sawEOF')\n\nconst noop = _ => true\n\nmodule.exports = warner(class Parser extends EE {\n  constructor (opt) {\n    opt = opt || {}\n    super(opt)\n\n    this.file = opt.file || ''\n\n    // set to boolean false when an entry starts.  1024 bytes of \\0\n    // is technically a valid tarball, albeit a boring one.\n    this[SAW_VALID_ENTRY] = null\n\n    // these BADARCHIVE errors can't be detected early. listen on DONE.\n    this.on(DONE, _ => {\n      if (this[STATE] === 'begin' || this[SAW_VALID_ENTRY] === false) {\n        // either less than 1 block of data, or all entries were invalid.\n        // Either way, probably not even a tarball.\n        this.warn('TAR_BAD_ARCHIVE', 'Unrecognized archive format')\n      }\n    })\n\n    if (opt.ondone)\n      this.on(DONE, opt.ondone)\n    else {\n      this.on(DONE, _ => {\n        this.emit('prefinish')\n        this.emit('finish')\n        this.emit('end')\n        this.emit('close')\n      })\n    }\n\n    this.strict = !!opt.strict\n    this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize\n    this.filter = typeof opt.filter === 'function' ? opt.filter : noop\n\n    // have to set this so that streams are ok piping into it\n    this.writable = true\n    this.readable = false\n\n    this[QUEUE] = new Yallist()\n    this[BUFFER] = null\n    this[READENTRY] = null\n    this[WRITEENTRY] = null\n    this[STATE] = 'begin'\n    this[META] = ''\n    this[EX] = null\n    this[GEX] = null\n    this[ENDED] = false\n    this[UNZIP] = null\n    this[ABORTED] = false\n    this[SAW_NULL_BLOCK] = false\n    this[SAW_EOF] = false\n    if (typeof opt.onwarn === 'function')\n      this.on('warn', opt.onwarn)\n    if (typeof opt.onentry === 'function')\n      this.on('entry', opt.onentry)\n  }\n\n  [CONSUMEHEADER] (chunk, position) {\n    if (this[SAW_VALID_ENTRY] === null)\n      this[SAW_VALID_ENTRY] = false\n    let header\n    try {\n      header = new Header(chunk, position, this[EX], this[GEX])\n    } catch (er) {\n      return this.warn('TAR_ENTRY_INVALID', er)\n    }\n\n    if (header.nullBlock) {\n      if (this[SAW_NULL_BLOCK]) {\n        this[SAW_EOF] = true\n        // ending an archive with no entries.  pointless, but legal.\n        if (this[STATE] === 'begin')\n          this[STATE] = 'header'\n        this[EMIT]('eof')\n      } else {\n        this[SAW_NULL_BLOCK] = true\n        this[EMIT]('nullBlock')\n      }\n    } else {\n      this[SAW_NULL_BLOCK] = false\n      if (!header.cksumValid)\n        this.warn('TAR_ENTRY_INVALID', 'checksum failure', {header})\n      else if (!header.path)\n        this.warn('TAR_ENTRY_INVALID', 'path is required', {header})\n      else {\n        const type = header.type\n        if (/^(Symbolic)?Link$/.test(type) && !header.linkpath)\n          this.warn('TAR_ENTRY_INVALID', 'linkpath required', {header})\n        else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath)\n          this.warn('TAR_ENTRY_INVALID', 'linkpath forbidden', {header})\n        else {\n          const entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX])\n\n          // we do this for meta & ignored entries as well, because they\n          // are still valid tar, or else we wouldn't know to ignore them\n          if (!this[SAW_VALID_ENTRY]) {\n            if (entry.remain) {\n              // this might be the one!\n              const onend = () => {\n                if (!entry.invalid)\n                  this[SAW_VALID_ENTRY] = true\n              }\n              entry.on('end', onend)\n            } else\n              this[SAW_VALID_ENTRY] = true\n          }\n\n          if (entry.meta) {\n            if (entry.size > this.maxMetaEntrySize) {\n              entry.ignore = true\n              this[EMIT]('ignoredEntry', entry)\n              this[STATE] = 'ignore'\n              entry.resume()\n            } else if (entry.size > 0) {\n              this[META] = ''\n              entry.on('data', c => this[META] += c)\n              this[STATE] = 'meta'\n            }\n          } else {\n            this[EX] = null\n            entry.ignore = entry.ignore || !this.filter(entry.path, entry)\n\n            if (entry.ignore) {\n              // probably valid, just not something we care about\n              this[EMIT]('ignoredEntry', entry)\n              this[STATE] = entry.remain ? 'ignore' : 'header'\n              entry.resume()\n            } else {\n              if (entry.remain)\n                this[STATE] = 'body'\n              else {\n                this[STATE] = 'header'\n                entry.end()\n              }\n\n              if (!this[READENTRY]) {\n                this[QUEUE].push(entry)\n                this[NEXTENTRY]()\n              } else\n                this[QUEUE].push(entry)\n            }\n          }\n        }\n      }\n    }\n  }\n\n  [PROCESSENTRY] (entry) {\n    let go = true\n\n    if (!entry) {\n      this[READENTRY] = null\n      go = false\n    } else if (Array.isArray(entry))\n      this.emit.apply(this, entry)\n    else {\n      this[READENTRY] = entry\n      this.emit('entry', entry)\n      if (!entry.emittedEnd) {\n        entry.on('end', _ => this[NEXTENTRY]())\n        go = false\n      }\n    }\n\n    return go\n  }\n\n  [NEXTENTRY] () {\n    do {} while (this[PROCESSENTRY](this[QUEUE].shift()))\n\n    if (!this[QUEUE].length) {\n      // At this point, there's nothing in the queue, but we may have an\n      // entry which is being consumed (readEntry).\n      // If we don't, then we definitely can handle more data.\n      // If we do, and either it's flowing, or it has never had any data\n      // written to it, then it needs more.\n      // The only other possibility is that it has returned false from a\n      // write() call, so we wait for the next drain to continue.\n      const re = this[READENTRY]\n      const drainNow = !re || re.flowing || re.size === re.remain\n      if (drainNow) {\n        if (!this[WRITING])\n          this.emit('drain')\n      } else\n        re.once('drain', _ => this.emit('drain'))\n    }\n  }\n\n  [CONSUMEBODY] (chunk, position) {\n    // write up to but no  more than writeEntry.blockRemain\n    const entry = this[WRITEENTRY]\n    const br = entry.blockRemain\n    const c = (br >= chunk.length && position === 0) ? chunk\n      : chunk.slice(position, position + br)\n\n    entry.write(c)\n\n    if (!entry.blockRemain) {\n      this[STATE] = 'header'\n      this[WRITEENTRY] = null\n      entry.end()\n    }\n\n    return c.length\n  }\n\n  [CONSUMEMETA] (chunk, position) {\n    const entry = this[WRITEENTRY]\n    const ret = this[CONSUMEBODY](chunk, position)\n\n    // if we finished, then the entry is reset\n    if (!this[WRITEENTRY])\n      this[EMITMETA](entry)\n\n    return ret\n  }\n\n  [EMIT] (ev, data, extra) {\n    if (!this[QUEUE].length && !this[READENTRY])\n      this.emit(ev, data, extra)\n    else\n      this[QUEUE].push([ev, data, extra])\n  }\n\n  [EMITMETA] (entry) {\n    this[EMIT]('meta', this[META])\n    switch (entry.type) {\n      case 'ExtendedHeader':\n      case 'OldExtendedHeader':\n        this[EX] = Pax.parse(this[META], this[EX], false)\n        break\n\n      case 'GlobalExtendedHeader':\n        this[GEX] = Pax.parse(this[META], this[GEX], true)\n        break\n\n      case 'NextFileHasLongPath':\n      case 'OldGnuLongPath':\n        this[EX] = this[EX] || Object.create(null)\n        this[EX].path = this[META].replace(/\\0.*/, '')\n        break\n\n      case 'NextFileHasLongLinkpath':\n        this[EX] = this[EX] || Object.create(null)\n        this[EX].linkpath = this[META].replace(/\\0.*/, '')\n        break\n\n      /* istanbul ignore next */\n      default: throw new Error('unknown meta: ' + entry.type)\n    }\n  }\n\n  abort (error) {\n    this[ABORTED] = true\n    this.emit('abort', error)\n    // always throws, even in non-strict mode\n    this.warn('TAR_ABORT', error, { recoverable: false })\n  }\n\n  write (chunk) {\n    if (this[ABORTED])\n      return\n\n    // first write, might be gzipped\n    if (this[UNZIP] === null && chunk) {\n      if (this[BUFFER]) {\n        chunk = Buffer.concat([this[BUFFER], chunk])\n        this[BUFFER] = null\n      }\n      if (chunk.length < gzipHeader.length) {\n        this[BUFFER] = chunk\n        return true\n      }\n      for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) {\n        if (chunk[i] !== gzipHeader[i])\n          this[UNZIP] = false\n      }\n      if (this[UNZIP] === null) {\n        const ended = this[ENDED]\n        this[ENDED] = false\n        this[UNZIP] = new zlib.Unzip()\n        this[UNZIP].on('data', chunk => this[CONSUMECHUNK](chunk))\n        this[UNZIP].on('error', er => this.abort(er))\n        this[UNZIP].on('end', _ => {\n          this[ENDED] = true\n          this[CONSUMECHUNK]()\n        })\n        this[WRITING] = true\n        const ret = this[UNZIP][ended ? 'end' : 'write'](chunk)\n        this[WRITING] = false\n        return ret\n      }\n    }\n\n    this[WRITING] = true\n    if (this[UNZIP])\n      this[UNZIP].write(chunk)\n    else\n      this[CONSUMECHUNK](chunk)\n    this[WRITING] = false\n\n    // return false if there's a queue, or if the current entry isn't flowing\n    const ret =\n      this[QUEUE].length ? false :\n      this[READENTRY] ? this[READENTRY].flowing :\n      true\n\n    // if we have no queue, then that means a clogged READENTRY\n    if (!ret && !this[QUEUE].length)\n      this[READENTRY].once('drain', _ => this.emit('drain'))\n\n    return ret\n  }\n\n  [BUFFERCONCAT] (c) {\n    if (c && !this[ABORTED])\n      this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c\n  }\n\n  [MAYBEEND] () {\n    if (this[ENDED] &&\n        !this[EMITTEDEND] &&\n        !this[ABORTED] &&\n        !this[CONSUMING]) {\n      this[EMITTEDEND] = true\n      const entry = this[WRITEENTRY]\n      if (entry && entry.blockRemain) {\n        // truncated, likely a damaged file\n        const have = this[BUFFER] ? this[BUFFER].length : 0\n        this.warn('TAR_BAD_ARCHIVE', `Truncated input (needed ${\n          entry.blockRemain} more bytes, only ${have} available)`, {entry})\n        if (this[BUFFER])\n          entry.write(this[BUFFER])\n        entry.end()\n      }\n      this[EMIT](DONE)\n    }\n  }\n\n  [CONSUMECHUNK] (chunk) {\n    if (this[CONSUMING])\n      this[BUFFERCONCAT](chunk)\n    else if (!chunk && !this[BUFFER])\n      this[MAYBEEND]()\n    else {\n      this[CONSUMING] = true\n      if (this[BUFFER]) {\n        this[BUFFERCONCAT](chunk)\n        const c = this[BUFFER]\n        this[BUFFER] = null\n        this[CONSUMECHUNKSUB](c)\n      } else\n        this[CONSUMECHUNKSUB](chunk)\n\n      while (this[BUFFER] &&\n          this[BUFFER].length >= 512 &&\n          !this[ABORTED] &&\n          !this[SAW_EOF]) {\n        const c = this[BUFFER]\n        this[BUFFER] = null\n        this[CONSUMECHUNKSUB](c)\n      }\n      this[CONSUMING] = false\n    }\n\n    if (!this[BUFFER] || this[ENDED])\n      this[MAYBEEND]()\n  }\n\n  [CONSUMECHUNKSUB] (chunk) {\n    // we know that we are in CONSUMING mode, so anything written goes into\n    // the buffer.  Advance the position and put any remainder in the buffer.\n    let position = 0\n    const length = chunk.length\n    while (position + 512 <= length && !this[ABORTED] && !this[SAW_EOF]) {\n      switch (this[STATE]) {\n        case 'begin':\n        case 'header':\n          this[CONSUMEHEADER](chunk, position)\n          position += 512\n          break\n\n        case 'ignore':\n        case 'body':\n          position += this[CONSUMEBODY](chunk, position)\n          break\n\n        case 'meta':\n          position += this[CONSUMEMETA](chunk, position)\n          break\n\n        /* istanbul ignore next */\n        default:\n          throw new Error('invalid state: ' + this[STATE])\n      }\n    }\n\n    if (position < length) {\n      if (this[BUFFER])\n        this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]])\n      else\n        this[BUFFER] = chunk.slice(position)\n    }\n  }\n\n  end (chunk) {\n    if (!this[ABORTED]) {\n      if (this[UNZIP])\n        this[UNZIP].end(chunk)\n      else {\n        this[ENDED] = true\n        this.write(chunk)\n      }\n    }\n  }\n})\n"]},"metadata":{},"sourceType":"script"}