{"ast":null,"code":"'use strict';\n\nvar _defineProperty = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _get = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _classCallCheck = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _wrapNativeSuper = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\n\nvar assert = require('assert');\n\nvar Buffer = require('buffer').Buffer;\n\nvar realZlib = require('zlib');\n\nvar constants = exports.constants = require('./constants.js');\n\nvar Minipass = require('minipass');\n\nvar OriginalBufferConcat = Buffer.concat;\n\nvar _superWrite = Symbol('_superWrite');\n\nvar ZlibError = /*#__PURE__*/function (_Error) {\n  _inherits(ZlibError, _Error);\n\n  var _super = _createSuper(ZlibError);\n\n  function ZlibError(err) {\n    var _this;\n\n    _classCallCheck(this, ZlibError);\n\n    _this = _super.call(this, 'zlib: ' + err.message);\n    _this.code = err.code;\n    _this.errno = err.errno;\n    /* istanbul ignore if */\n\n    if (!_this.code) _this.code = 'ZLIB_ERROR';\n    _this.message = 'zlib: ' + err.message;\n    Error.captureStackTrace(_assertThisInitialized(_this), _this.constructor);\n    return _this;\n  }\n\n  _createClass(ZlibError, [{\n    key: \"name\",\n    get: function get() {\n      return 'ZlibError';\n    }\n  }]);\n\n  return ZlibError;\n}( /*#__PURE__*/_wrapNativeSuper(Error)); // the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\n\n\nvar _opts = Symbol('opts');\n\nvar _flushFlag = Symbol('flushFlag');\n\nvar _finishFlushFlag = Symbol('finishFlushFlag');\n\nvar _fullFlushFlag = Symbol('fullFlushFlag');\n\nvar _handle = Symbol('handle');\n\nvar _onError = Symbol('onError');\n\nvar _sawError = Symbol('sawError');\n\nvar _level = Symbol('level');\n\nvar _strategy = Symbol('strategy');\n\nvar _ended = Symbol('ended');\n\nvar _defaultFullFlush = Symbol('_defaultFullFlush');\n\nvar ZlibBase = /*#__PURE__*/function (_Minipass) {\n  _inherits(ZlibBase, _Minipass);\n\n  var _super2 = _createSuper(ZlibBase);\n\n  function ZlibBase(opts, mode) {\n    var _this2;\n\n    _classCallCheck(this, ZlibBase);\n\n    if (!opts || typeof opts !== 'object') throw new TypeError('invalid options for ZlibBase constructor');\n    _this2 = _super2.call(this, opts);\n    _this2[_sawError] = false;\n    _this2[_ended] = false;\n    _this2[_opts] = opts;\n    _this2[_flushFlag] = opts.flush;\n    _this2[_finishFlushFlag] = opts.finishFlush; // this will throw if any options are invalid for the class selected\n\n    try {\n      _this2[_handle] = new realZlib[mode](opts);\n    } catch (er) {\n      // make sure that all errors get decorated properly\n      throw new ZlibError(er);\n    }\n\n    _this2[_onError] = function (err) {\n      // no sense raising multiple errors, since we abort on the first one.\n      if (_this2[_sawError]) return;\n      _this2[_sawError] = true; // there is no way to cleanly recover.\n      // continuing only obscures problems.\n\n      _this2.close();\n\n      _this2.emit('error', err);\n    };\n\n    _this2[_handle].on('error', function (er) {\n      return _this2[_onError](new ZlibError(er));\n    });\n\n    _this2.once('end', function () {\n      return _this2.close;\n    });\n\n    return _this2;\n  }\n\n  _createClass(ZlibBase, [{\n    key: \"close\",\n    value: function close() {\n      if (this[_handle]) {\n        this[_handle].close();\n\n        this[_handle] = null;\n        this.emit('close');\n      }\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      if (!this[_sawError]) {\n        assert(this[_handle], 'zlib binding closed');\n        return this[_handle].reset();\n      }\n    }\n  }, {\n    key: \"flush\",\n    value: function flush(flushFlag) {\n      if (this.ended) return;\n      if (typeof flushFlag !== 'number') flushFlag = this[_fullFlushFlag];\n      this.write(Object.assign(Buffer.alloc(0), _defineProperty({}, _flushFlag, flushFlag)));\n    }\n  }, {\n    key: \"end\",\n    value: function end(chunk, encoding, cb) {\n      if (chunk) this.write(chunk, encoding);\n      this.flush(this[_finishFlushFlag]);\n      this[_ended] = true;\n      return _get(_getPrototypeOf(ZlibBase.prototype), \"end\", this).call(this, null, null, cb);\n    }\n  }, {\n    key: \"ended\",\n    get: function get() {\n      return this[_ended];\n    }\n  }, {\n    key: \"write\",\n    value: function write(chunk, encoding, cb) {\n      var _this3 = this;\n\n      // process the chunk using the sync process\n      // then super.write() all the outputted chunks\n      if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n      if (typeof chunk === 'string') chunk = Buffer.from(chunk, encoding);\n      if (this[_sawError]) return;\n      assert(this[_handle], 'zlib binding closed'); // _processChunk tries to .close() the native handle after it's done, so we\n      // intercept that by temporarily making it a no-op.\n\n      var nativeHandle = this[_handle]._handle;\n      var originalNativeClose = nativeHandle.close;\n\n      nativeHandle.close = function () {};\n\n      var originalClose = this[_handle].close;\n\n      this[_handle].close = function () {}; // It also calls `Buffer.concat()` at the end, which may be convenient\n      // for some, but which we are not interested in as it slows us down.\n\n\n      Buffer.concat = function (args) {\n        return args;\n      };\n\n      var result;\n\n      try {\n        var flushFlag = typeof chunk[_flushFlag] === 'number' ? chunk[_flushFlag] : this[_flushFlag];\n        result = this[_handle]._processChunk(chunk, flushFlag); // if we don't throw, reset it back how it was\n\n        Buffer.concat = OriginalBufferConcat;\n      } catch (err) {\n        // or if we do, put Buffer.concat() back before we emit error\n        // Error events call into user code, which may call Buffer.concat()\n        Buffer.concat = OriginalBufferConcat;\n\n        this[_onError](new ZlibError(err));\n      } finally {\n        if (this[_handle]) {\n          // Core zlib resets `_handle` to null after attempting to close the\n          // native handle. Our no-op handler prevented actual closure, but we\n          // need to restore the `._handle` property.\n          this[_handle]._handle = nativeHandle;\n          nativeHandle.close = originalNativeClose;\n          this[_handle].close = originalClose; // `_processChunk()` adds an 'error' listener. If we don't remove it\n          // after each call, these handlers start piling up.\n\n          this[_handle].removeAllListeners('error'); // make sure OUR error listener is still attached tho\n\n        }\n      }\n\n      if (this[_handle]) this[_handle].on('error', function (er) {\n        return _this3[_onError](new ZlibError(er));\n      });\n      var writeReturn;\n\n      if (result) {\n        if (Array.isArray(result) && result.length > 0) {\n          // The first buffer is always `handle._outBuffer`, which would be\n          // re-used for later invocations; so, we always have to copy that one.\n          writeReturn = this[_superWrite](Buffer.from(result[0]));\n\n          for (var i = 1; i < result.length; i++) {\n            writeReturn = this[_superWrite](result[i]);\n          }\n        } else {\n          writeReturn = this[_superWrite](Buffer.from(result));\n        }\n      }\n\n      if (cb) cb();\n      return writeReturn;\n    }\n  }, {\n    key: _superWrite,\n    value: function value(data) {\n      return _get(_getPrototypeOf(ZlibBase.prototype), \"write\", this).call(this, data);\n    }\n  }]);\n\n  return ZlibBase;\n}(Minipass);\n\nvar Zlib = /*#__PURE__*/function (_ZlibBase) {\n  _inherits(Zlib, _ZlibBase);\n\n  var _super3 = _createSuper(Zlib);\n\n  function Zlib(opts, mode) {\n    var _this4;\n\n    _classCallCheck(this, Zlib);\n\n    opts = opts || {};\n    opts.flush = opts.flush || constants.Z_NO_FLUSH;\n    opts.finishFlush = opts.finishFlush || constants.Z_FINISH;\n    _this4 = _super3.call(this, opts, mode);\n    _this4[_fullFlushFlag] = constants.Z_FULL_FLUSH;\n    _this4[_level] = opts.level;\n    _this4[_strategy] = opts.strategy;\n    return _this4;\n  }\n\n  _createClass(Zlib, [{\n    key: \"params\",\n    value: function params(level, strategy) {\n      var _this5 = this;\n\n      if (this[_sawError]) return;\n      if (!this[_handle]) throw new Error('cannot switch params when binding is closed'); // no way to test this without also not supporting params at all\n\n      /* istanbul ignore if */\n\n      if (!this[_handle].params) throw new Error('not supported in this implementation');\n\n      if (this[_level] !== level || this[_strategy] !== strategy) {\n        this.flush(constants.Z_SYNC_FLUSH);\n        assert(this[_handle], 'zlib binding closed'); // .params() calls .flush(), but the latter is always async in the\n        // core zlib. We override .flush() temporarily to intercept that and\n        // flush synchronously.\n\n        var origFlush = this[_handle].flush;\n\n        this[_handle].flush = function (flushFlag, cb) {\n          _this5.flush(flushFlag);\n\n          cb();\n        };\n\n        try {\n          this[_handle].params(level, strategy);\n        } finally {\n          this[_handle].flush = origFlush;\n        }\n        /* istanbul ignore else */\n\n\n        if (this[_handle]) {\n          this[_level] = level;\n          this[_strategy] = strategy;\n        }\n      }\n    }\n  }]);\n\n  return Zlib;\n}(ZlibBase); // minimal 2-byte header\n\n\nvar Deflate = /*#__PURE__*/function (_Zlib) {\n  _inherits(Deflate, _Zlib);\n\n  var _super4 = _createSuper(Deflate);\n\n  function Deflate(opts) {\n    _classCallCheck(this, Deflate);\n\n    return _super4.call(this, opts, 'Deflate');\n  }\n\n  return Deflate;\n}(Zlib);\n\nvar Inflate = /*#__PURE__*/function (_Zlib2) {\n  _inherits(Inflate, _Zlib2);\n\n  var _super5 = _createSuper(Inflate);\n\n  function Inflate(opts) {\n    _classCallCheck(this, Inflate);\n\n    return _super5.call(this, opts, 'Inflate');\n  }\n\n  return Inflate;\n}(Zlib); // gzip - bigger header, same deflate compression\n\n\nvar _portable = Symbol('_portable');\n\nvar Gzip = /*#__PURE__*/function (_Zlib3) {\n  _inherits(Gzip, _Zlib3);\n\n  var _super6 = _createSuper(Gzip);\n\n  function Gzip(opts) {\n    var _this6;\n\n    _classCallCheck(this, Gzip);\n\n    _this6 = _super6.call(this, opts, 'Gzip');\n    _this6[_portable] = opts && !!opts.portable;\n    return _this6;\n  }\n\n  _createClass(Gzip, [{\n    key: _superWrite,\n    value: function value(data) {\n      if (!this[_portable]) return _get(_getPrototypeOf(Gzip.prototype), _superWrite, this).call(this, data); // we'll always get the header emitted in one first chunk\n      // overwrite the OS indicator byte with 0xFF\n\n      this[_portable] = false;\n      data[9] = 255;\n      return _get(_getPrototypeOf(Gzip.prototype), _superWrite, this).call(this, data);\n    }\n  }]);\n\n  return Gzip;\n}(Zlib);\n\nvar Gunzip = /*#__PURE__*/function (_Zlib4) {\n  _inherits(Gunzip, _Zlib4);\n\n  var _super7 = _createSuper(Gunzip);\n\n  function Gunzip(opts) {\n    _classCallCheck(this, Gunzip);\n\n    return _super7.call(this, opts, 'Gunzip');\n  }\n\n  return Gunzip;\n}(Zlib); // raw - no header\n\n\nvar DeflateRaw = /*#__PURE__*/function (_Zlib5) {\n  _inherits(DeflateRaw, _Zlib5);\n\n  var _super8 = _createSuper(DeflateRaw);\n\n  function DeflateRaw(opts) {\n    _classCallCheck(this, DeflateRaw);\n\n    return _super8.call(this, opts, 'DeflateRaw');\n  }\n\n  return DeflateRaw;\n}(Zlib);\n\nvar InflateRaw = /*#__PURE__*/function (_Zlib6) {\n  _inherits(InflateRaw, _Zlib6);\n\n  var _super9 = _createSuper(InflateRaw);\n\n  function InflateRaw(opts) {\n    _classCallCheck(this, InflateRaw);\n\n    return _super9.call(this, opts, 'InflateRaw');\n  }\n\n  return InflateRaw;\n}(Zlib); // auto-detect header.\n\n\nvar Unzip = /*#__PURE__*/function (_Zlib7) {\n  _inherits(Unzip, _Zlib7);\n\n  var _super10 = _createSuper(Unzip);\n\n  function Unzip(opts) {\n    _classCallCheck(this, Unzip);\n\n    return _super10.call(this, opts, 'Unzip');\n  }\n\n  return Unzip;\n}(Zlib);\n\nvar Brotli = /*#__PURE__*/function (_ZlibBase2) {\n  _inherits(Brotli, _ZlibBase2);\n\n  var _super11 = _createSuper(Brotli);\n\n  function Brotli(opts, mode) {\n    var _this7;\n\n    _classCallCheck(this, Brotli);\n\n    opts = opts || {};\n    opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS;\n    opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH;\n    _this7 = _super11.call(this, opts, mode);\n    _this7[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH;\n    return _this7;\n  }\n\n  return Brotli;\n}(ZlibBase);\n\nvar BrotliCompress = /*#__PURE__*/function (_Brotli) {\n  _inherits(BrotliCompress, _Brotli);\n\n  var _super12 = _createSuper(BrotliCompress);\n\n  function BrotliCompress(opts) {\n    _classCallCheck(this, BrotliCompress);\n\n    return _super12.call(this, opts, 'BrotliCompress');\n  }\n\n  return BrotliCompress;\n}(Brotli);\n\nvar BrotliDecompress = /*#__PURE__*/function (_Brotli2) {\n  _inherits(BrotliDecompress, _Brotli2);\n\n  var _super13 = _createSuper(BrotliDecompress);\n\n  function BrotliDecompress(opts) {\n    _classCallCheck(this, BrotliDecompress);\n\n    return _super13.call(this, opts, 'BrotliDecompress');\n  }\n\n  return BrotliDecompress;\n}(Brotli);\n\nexports.Deflate = Deflate;\nexports.Inflate = Inflate;\nexports.Gzip = Gzip;\nexports.Gunzip = Gunzip;\nexports.DeflateRaw = DeflateRaw;\nexports.InflateRaw = InflateRaw;\nexports.Unzip = Unzip;\n/* istanbul ignore else */\n\nif (typeof realZlib.BrotliCompress === 'function') {\n  exports.BrotliCompress = BrotliCompress;\n  exports.BrotliDecompress = BrotliDecompress;\n} else {\n  exports.BrotliCompress = exports.BrotliDecompress = /*#__PURE__*/function () {\n    function _class() {\n      _classCallCheck(this, _class);\n\n      throw new Error('Brotli is not supported in this version of Node.js');\n    }\n\n    return _class;\n  }();\n}","map":{"version":3,"sources":["/Users/austenhughes/The-Baffoonery/node_modules/minizlib/index.js"],"names":["assert","require","Buffer","realZlib","constants","exports","Minipass","OriginalBufferConcat","concat","_superWrite","Symbol","ZlibError","err","message","code","errno","Error","captureStackTrace","constructor","_opts","_flushFlag","_finishFlushFlag","_fullFlushFlag","_handle","_onError","_sawError","_level","_strategy","_ended","_defaultFullFlush","ZlibBase","opts","mode","TypeError","flush","finishFlush","er","close","emit","on","once","reset","flushFlag","ended","write","Object","assign","alloc","chunk","encoding","cb","from","nativeHandle","originalNativeClose","originalClose","args","result","_processChunk","removeAllListeners","writeReturn","Array","isArray","length","i","data","Zlib","Z_NO_FLUSH","Z_FINISH","Z_FULL_FLUSH","level","strategy","params","Z_SYNC_FLUSH","origFlush","Deflate","Inflate","_portable","Gzip","portable","Gunzip","DeflateRaw","InflateRaw","Unzip","Brotli","BROTLI_OPERATION_PROCESS","BROTLI_OPERATION_FINISH","BROTLI_OPERATION_FLUSH","BrotliCompress","BrotliDecompress"],"mappings":"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","sourcesContent":["'use strict'\n\nconst assert = require('assert')\nconst Buffer = require('buffer').Buffer\nconst realZlib = require('zlib')\n\nconst constants = exports.constants = require('./constants.js')\nconst Minipass = require('minipass')\n\nconst OriginalBufferConcat = Buffer.concat\n\nconst _superWrite = Symbol('_superWrite')\nclass ZlibError extends Error {\n  constructor (err) {\n    super('zlib: ' + err.message)\n    this.code = err.code\n    this.errno = err.errno\n    /* istanbul ignore if */\n    if (!this.code)\n      this.code = 'ZLIB_ERROR'\n\n    this.message = 'zlib: ' + err.message\n    Error.captureStackTrace(this, this.constructor)\n  }\n\n  get name () {\n    return 'ZlibError'\n  }\n}\n\n// the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\nconst _opts = Symbol('opts')\nconst _flushFlag = Symbol('flushFlag')\nconst _finishFlushFlag = Symbol('finishFlushFlag')\nconst _fullFlushFlag = Symbol('fullFlushFlag')\nconst _handle = Symbol('handle')\nconst _onError = Symbol('onError')\nconst _sawError = Symbol('sawError')\nconst _level = Symbol('level')\nconst _strategy = Symbol('strategy')\nconst _ended = Symbol('ended')\nconst _defaultFullFlush = Symbol('_defaultFullFlush')\n\nclass ZlibBase extends Minipass {\n  constructor (opts, mode) {\n    if (!opts || typeof opts !== 'object')\n      throw new TypeError('invalid options for ZlibBase constructor')\n\n    super(opts)\n    this[_sawError] = false\n    this[_ended] = false\n    this[_opts] = opts\n\n    this[_flushFlag] = opts.flush\n    this[_finishFlushFlag] = opts.finishFlush\n    // this will throw if any options are invalid for the class selected\n    try {\n      this[_handle] = new realZlib[mode](opts)\n    } catch (er) {\n      // make sure that all errors get decorated properly\n      throw new ZlibError(er)\n    }\n\n    this[_onError] = (err) => {\n      // no sense raising multiple errors, since we abort on the first one.\n      if (this[_sawError])\n        return\n\n      this[_sawError] = true\n\n      // there is no way to cleanly recover.\n      // continuing only obscures problems.\n      this.close()\n      this.emit('error', err)\n    }\n\n    this[_handle].on('error', er => this[_onError](new ZlibError(er)))\n    this.once('end', () => this.close)\n  }\n\n  close () {\n    if (this[_handle]) {\n      this[_handle].close()\n      this[_handle] = null\n      this.emit('close')\n    }\n  }\n\n  reset () {\n    if (!this[_sawError]) {\n      assert(this[_handle], 'zlib binding closed')\n      return this[_handle].reset()\n    }\n  }\n\n  flush (flushFlag) {\n    if (this.ended)\n      return\n\n    if (typeof flushFlag !== 'number')\n      flushFlag = this[_fullFlushFlag]\n    this.write(Object.assign(Buffer.alloc(0), { [_flushFlag]: flushFlag }))\n  }\n\n  end (chunk, encoding, cb) {\n    if (chunk)\n      this.write(chunk, encoding)\n    this.flush(this[_finishFlushFlag])\n    this[_ended] = true\n    return super.end(null, null, cb)\n  }\n\n  get ended () {\n    return this[_ended]\n  }\n\n  write (chunk, encoding, cb) {\n    // process the chunk using the sync process\n    // then super.write() all the outputted chunks\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n\n    if (typeof chunk === 'string')\n      chunk = Buffer.from(chunk, encoding)\n\n    if (this[_sawError])\n      return\n    assert(this[_handle], 'zlib binding closed')\n\n    // _processChunk tries to .close() the native handle after it's done, so we\n    // intercept that by temporarily making it a no-op.\n    const nativeHandle = this[_handle]._handle\n    const originalNativeClose = nativeHandle.close\n    nativeHandle.close = () => {}\n    const originalClose = this[_handle].close\n    this[_handle].close = () => {}\n    // It also calls `Buffer.concat()` at the end, which may be convenient\n    // for some, but which we are not interested in as it slows us down.\n    Buffer.concat = (args) => args\n    let result\n    try {\n      const flushFlag = typeof chunk[_flushFlag] === 'number'\n        ? chunk[_flushFlag] : this[_flushFlag]\n      result = this[_handle]._processChunk(chunk, flushFlag)\n      // if we don't throw, reset it back how it was\n      Buffer.concat = OriginalBufferConcat\n    } catch (err) {\n      // or if we do, put Buffer.concat() back before we emit error\n      // Error events call into user code, which may call Buffer.concat()\n      Buffer.concat = OriginalBufferConcat\n      this[_onError](new ZlibError(err))\n    } finally {\n      if (this[_handle]) {\n        // Core zlib resets `_handle` to null after attempting to close the\n        // native handle. Our no-op handler prevented actual closure, but we\n        // need to restore the `._handle` property.\n        this[_handle]._handle = nativeHandle\n        nativeHandle.close = originalNativeClose\n        this[_handle].close = originalClose\n        // `_processChunk()` adds an 'error' listener. If we don't remove it\n        // after each call, these handlers start piling up.\n        this[_handle].removeAllListeners('error')\n        // make sure OUR error listener is still attached tho\n      }\n    }\n\n    if (this[_handle])\n      this[_handle].on('error', er => this[_onError](new ZlibError(er)))\n\n    let writeReturn\n    if (result) {\n      if (Array.isArray(result) && result.length > 0) {\n        // The first buffer is always `handle._outBuffer`, which would be\n        // re-used for later invocations; so, we always have to copy that one.\n        writeReturn = this[_superWrite](Buffer.from(result[0]))\n        for (let i = 1; i < result.length; i++) {\n          writeReturn = this[_superWrite](result[i])\n        }\n      } else {\n        writeReturn = this[_superWrite](Buffer.from(result))\n      }\n    }\n\n    if (cb)\n      cb()\n    return writeReturn\n  }\n\n  [_superWrite] (data) {\n    return super.write(data)\n  }\n}\n\nclass Zlib extends ZlibBase {\n  constructor (opts, mode) {\n    opts = opts || {}\n\n    opts.flush = opts.flush || constants.Z_NO_FLUSH\n    opts.finishFlush = opts.finishFlush || constants.Z_FINISH\n    super(opts, mode)\n\n    this[_fullFlushFlag] = constants.Z_FULL_FLUSH\n    this[_level] = opts.level\n    this[_strategy] = opts.strategy\n  }\n\n  params (level, strategy) {\n    if (this[_sawError])\n      return\n\n    if (!this[_handle])\n      throw new Error('cannot switch params when binding is closed')\n\n    // no way to test this without also not supporting params at all\n    /* istanbul ignore if */\n    if (!this[_handle].params)\n      throw new Error('not supported in this implementation')\n\n    if (this[_level] !== level || this[_strategy] !== strategy) {\n      this.flush(constants.Z_SYNC_FLUSH)\n      assert(this[_handle], 'zlib binding closed')\n      // .params() calls .flush(), but the latter is always async in the\n      // core zlib. We override .flush() temporarily to intercept that and\n      // flush synchronously.\n      const origFlush = this[_handle].flush\n      this[_handle].flush = (flushFlag, cb) => {\n        this.flush(flushFlag)\n        cb()\n      }\n      try {\n        this[_handle].params(level, strategy)\n      } finally {\n        this[_handle].flush = origFlush\n      }\n      /* istanbul ignore else */\n      if (this[_handle]) {\n        this[_level] = level\n        this[_strategy] = strategy\n      }\n    }\n  }\n}\n\n// minimal 2-byte header\nclass Deflate extends Zlib {\n  constructor (opts) {\n    super(opts, 'Deflate')\n  }\n}\n\nclass Inflate extends Zlib {\n  constructor (opts) {\n    super(opts, 'Inflate')\n  }\n}\n\n// gzip - bigger header, same deflate compression\nconst _portable = Symbol('_portable')\nclass Gzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Gzip')\n    this[_portable] = opts && !!opts.portable\n  }\n\n  [_superWrite] (data) {\n    if (!this[_portable])\n      return super[_superWrite](data)\n\n    // we'll always get the header emitted in one first chunk\n    // overwrite the OS indicator byte with 0xFF\n    this[_portable] = false\n    data[9] = 255\n    return super[_superWrite](data)\n  }\n}\n\nclass Gunzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Gunzip')\n  }\n}\n\n// raw - no header\nclass DeflateRaw extends Zlib {\n  constructor (opts) {\n    super(opts, 'DeflateRaw')\n  }\n}\n\nclass InflateRaw extends Zlib {\n  constructor (opts) {\n    super(opts, 'InflateRaw')\n  }\n}\n\n// auto-detect header.\nclass Unzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Unzip')\n  }\n}\n\nclass Brotli extends ZlibBase {\n  constructor (opts, mode) {\n    opts = opts || {}\n\n    opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS\n    opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH\n\n    super(opts, mode)\n\n    this[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH\n  }\n}\n\nclass BrotliCompress extends Brotli {\n  constructor (opts) {\n    super(opts, 'BrotliCompress')\n  }\n}\n\nclass BrotliDecompress extends Brotli {\n  constructor (opts) {\n    super(opts, 'BrotliDecompress')\n  }\n}\n\nexports.Deflate = Deflate\nexports.Inflate = Inflate\nexports.Gzip = Gzip\nexports.Gunzip = Gunzip\nexports.DeflateRaw = DeflateRaw\nexports.InflateRaw = InflateRaw\nexports.Unzip = Unzip\n/* istanbul ignore else */\nif (typeof realZlib.BrotliCompress === 'function') {\n  exports.BrotliCompress = BrotliCompress\n  exports.BrotliDecompress = BrotliDecompress\n} else {\n  exports.BrotliCompress = exports.BrotliDecompress = class {\n    constructor () {\n      throw new Error('Brotli is not supported in this version of Node.js')\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}