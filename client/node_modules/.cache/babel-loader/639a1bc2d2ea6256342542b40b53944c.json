{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar MiniPass = require('minipass');\n\nvar EE = require('events').EventEmitter;\n\nvar fs = require('fs');\n\nvar writev = fs.writev;\n/* istanbul ignore next */\n\nif (!writev) {\n  // This entire block can be removed if support for earlier than Node.js\n  // 12.9.0 is not needed.\n  var binding = process.binding('fs');\n  var FSReqWrap = binding.FSReqWrap || binding.FSReqCallback;\n\n  writev = function writev(fd, iovec, pos, cb) {\n    var done = function done(er, bw) {\n      return cb(er, bw, iovec);\n    };\n\n    var req = new FSReqWrap();\n    req.oncomplete = done;\n    binding.writeBuffers(fd, iovec, pos, req);\n  };\n}\n\nvar _autoClose = Symbol('_autoClose');\n\nvar _close = Symbol('_close');\n\nvar _ended = Symbol('_ended');\n\nvar _fd = Symbol('_fd');\n\nvar _finished = Symbol('_finished');\n\nvar _flags = Symbol('_flags');\n\nvar _flush = Symbol('_flush');\n\nvar _handleChunk = Symbol('_handleChunk');\n\nvar _makeBuf = Symbol('_makeBuf');\n\nvar _mode = Symbol('_mode');\n\nvar _needDrain = Symbol('_needDrain');\n\nvar _onerror = Symbol('_onerror');\n\nvar _onopen = Symbol('_onopen');\n\nvar _onread = Symbol('_onread');\n\nvar _onwrite = Symbol('_onwrite');\n\nvar _open = Symbol('_open');\n\nvar _path = Symbol('_path');\n\nvar _pos = Symbol('_pos');\n\nvar _queue = Symbol('_queue');\n\nvar _read = Symbol('_read');\n\nvar _readSize = Symbol('_readSize');\n\nvar _reading = Symbol('_reading');\n\nvar _remain = Symbol('_remain');\n\nvar _size = Symbol('_size');\n\nvar _write = Symbol('_write');\n\nvar _writing = Symbol('_writing');\n\nvar _defaultFlag = Symbol('_defaultFlag');\n\nvar _errored = Symbol('_errored');\n\nvar ReadStream = /*#__PURE__*/function (_MiniPass) {\n  _inherits(ReadStream, _MiniPass);\n\n  var _super = _createSuper(ReadStream);\n\n  function ReadStream(path, opt) {\n    var _this;\n\n    _classCallCheck(this, ReadStream);\n\n    opt = opt || {};\n    _this = _super.call(this, opt);\n    _this.readable = true;\n    _this.writable = false;\n    if (typeof path !== 'string') throw new TypeError('path must be a string');\n    _this[_errored] = false;\n    _this[_fd] = typeof opt.fd === 'number' ? opt.fd : null;\n    _this[_path] = path;\n    _this[_readSize] = opt.readSize || 16 * 1024 * 1024;\n    _this[_reading] = false;\n    _this[_size] = typeof opt.size === 'number' ? opt.size : Infinity;\n    _this[_remain] = _this[_size];\n    _this[_autoClose] = typeof opt.autoClose === 'boolean' ? opt.autoClose : true;\n    if (typeof _this[_fd] === 'number') _this[_read]();else _this[_open]();\n    return _this;\n  }\n\n  _createClass(ReadStream, [{\n    key: \"fd\",\n    get: function get() {\n      return this[_fd];\n    }\n  }, {\n    key: \"path\",\n    get: function get() {\n      return this[_path];\n    }\n  }, {\n    key: \"write\",\n    value: function write() {\n      throw new TypeError('this is a readable stream');\n    }\n  }, {\n    key: \"end\",\n    value: function end() {\n      throw new TypeError('this is a readable stream');\n    }\n  }, {\n    key: _open,\n    value: function value() {\n      var _this2 = this;\n\n      fs.open(this[_path], 'r', function (er, fd) {\n        return _this2[_onopen](er, fd);\n      });\n    }\n  }, {\n    key: _onopen,\n    value: function value(er, fd) {\n      if (er) this[_onerror](er);else {\n        this[_fd] = fd;\n        this.emit('open', fd);\n\n        this[_read]();\n      }\n    }\n  }, {\n    key: _makeBuf,\n    value: function value() {\n      return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]));\n    }\n  }, {\n    key: _read,\n    value: function value() {\n      var _this3 = this;\n\n      if (!this[_reading]) {\n        this[_reading] = true;\n\n        var buf = this[_makeBuf]();\n        /* istanbul ignore if */\n\n\n        if (buf.length === 0) return process.nextTick(function () {\n          return _this3[_onread](null, 0, buf);\n        });\n        fs.read(this[_fd], buf, 0, buf.length, null, function (er, br, buf) {\n          return _this3[_onread](er, br, buf);\n        });\n      }\n    }\n  }, {\n    key: _onread,\n    value: function value(er, br, buf) {\n      this[_reading] = false;\n      if (er) this[_onerror](er);else if (this[_handleChunk](br, buf)) this[_read]();\n    }\n  }, {\n    key: _close,\n    value: function value() {\n      var _this4 = this;\n\n      if (this[_autoClose] && typeof this[_fd] === 'number') {\n        var fd = this[_fd];\n        this[_fd] = null;\n        fs.close(fd, function (er) {\n          return er ? _this4.emit('error', er) : _this4.emit('close');\n        });\n      }\n    }\n  }, {\n    key: _onerror,\n    value: function value(er) {\n      this[_reading] = true;\n\n      this[_close]();\n\n      this.emit('error', er);\n    }\n  }, {\n    key: _handleChunk,\n    value: function value(br, buf) {\n      var ret = false; // no effect if infinite\n\n      this[_remain] -= br;\n      if (br > 0) ret = _get(_getPrototypeOf(ReadStream.prototype), \"write\", this).call(this, br < buf.length ? buf.slice(0, br) : buf);\n\n      if (br === 0 || this[_remain] <= 0) {\n        ret = false;\n\n        this[_close]();\n\n        _get(_getPrototypeOf(ReadStream.prototype), \"end\", this).call(this);\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(ev, data) {\n      switch (ev) {\n        case 'prefinish':\n        case 'finish':\n          break;\n\n        case 'drain':\n          if (typeof this[_fd] === 'number') this[_read]();\n          break;\n\n        case 'error':\n          if (this[_errored]) return;\n          this[_errored] = true;\n          return _get(_getPrototypeOf(ReadStream.prototype), \"emit\", this).call(this, ev, data);\n\n        default:\n          return _get(_getPrototypeOf(ReadStream.prototype), \"emit\", this).call(this, ev, data);\n      }\n    }\n  }]);\n\n  return ReadStream;\n}(MiniPass);\n\nvar ReadStreamSync = /*#__PURE__*/function (_ReadStream) {\n  _inherits(ReadStreamSync, _ReadStream);\n\n  var _super2 = _createSuper(ReadStreamSync);\n\n  function ReadStreamSync() {\n    _classCallCheck(this, ReadStreamSync);\n\n    return _super2.apply(this, arguments);\n  }\n\n  _createClass(ReadStreamSync, [{\n    key: _open,\n    value: function value() {\n      var threw = true;\n\n      try {\n        this[_onopen](null, fs.openSync(this[_path], 'r'));\n\n        threw = false;\n      } finally {\n        if (threw) this[_close]();\n      }\n    }\n  }, {\n    key: _read,\n    value: function value() {\n      var threw = true;\n\n      try {\n        if (!this[_reading]) {\n          this[_reading] = true;\n\n          do {\n            var buf = this[_makeBuf]();\n            /* istanbul ignore next */\n\n\n            var br = buf.length === 0 ? 0 : fs.readSync(this[_fd], buf, 0, buf.length, null);\n            if (!this[_handleChunk](br, buf)) break;\n          } while (true);\n\n          this[_reading] = false;\n        }\n\n        threw = false;\n      } finally {\n        if (threw) this[_close]();\n      }\n    }\n  }, {\n    key: _close,\n    value: function value() {\n      if (this[_autoClose] && typeof this[_fd] === 'number') {\n        var fd = this[_fd];\n        this[_fd] = null;\n        fs.closeSync(fd);\n        this.emit('close');\n      }\n    }\n  }]);\n\n  return ReadStreamSync;\n}(ReadStream);\n\nvar WriteStream = /*#__PURE__*/function (_EE) {\n  _inherits(WriteStream, _EE);\n\n  var _super3 = _createSuper(WriteStream);\n\n  function WriteStream(path, opt) {\n    var _this5;\n\n    _classCallCheck(this, WriteStream);\n\n    opt = opt || {};\n    _this5 = _super3.call(this, opt);\n    _this5.readable = false;\n    _this5.writable = true;\n    _this5[_errored] = false;\n    _this5[_writing] = false;\n    _this5[_ended] = false;\n    _this5[_needDrain] = false;\n    _this5[_queue] = [];\n    _this5[_path] = path;\n    _this5[_fd] = typeof opt.fd === 'number' ? opt.fd : null;\n    _this5[_mode] = opt.mode === undefined ? 438 : opt.mode;\n    _this5[_pos] = typeof opt.start === 'number' ? opt.start : null;\n    _this5[_autoClose] = typeof opt.autoClose === 'boolean' ? opt.autoClose : true; // truncating makes no sense when writing into the middle\n\n    var defaultFlag = _this5[_pos] !== null ? 'r+' : 'w';\n    _this5[_defaultFlag] = opt.flags === undefined;\n    _this5[_flags] = _this5[_defaultFlag] ? defaultFlag : opt.flags;\n    if (_this5[_fd] === null) _this5[_open]();\n    return _this5;\n  }\n\n  _createClass(WriteStream, [{\n    key: \"emit\",\n    value: function emit(ev, data) {\n      if (ev === 'error') {\n        if (this[_errored]) return;\n        this[_errored] = true;\n      }\n\n      return _get(_getPrototypeOf(WriteStream.prototype), \"emit\", this).call(this, ev, data);\n    }\n  }, {\n    key: \"fd\",\n    get: function get() {\n      return this[_fd];\n    }\n  }, {\n    key: \"path\",\n    get: function get() {\n      return this[_path];\n    }\n  }, {\n    key: _onerror,\n    value: function value(er) {\n      this[_close]();\n\n      this[_writing] = true;\n      this.emit('error', er);\n    }\n  }, {\n    key: _open,\n    value: function value() {\n      var _this6 = this;\n\n      fs.open(this[_path], this[_flags], this[_mode], function (er, fd) {\n        return _this6[_onopen](er, fd);\n      });\n    }\n  }, {\n    key: _onopen,\n    value: function value(er, fd) {\n      if (this[_defaultFlag] && this[_flags] === 'r+' && er && er.code === 'ENOENT') {\n        this[_flags] = 'w';\n\n        this[_open]();\n      } else if (er) this[_onerror](er);else {\n        this[_fd] = fd;\n        this.emit('open', fd);\n\n        this[_flush]();\n      }\n    }\n  }, {\n    key: \"end\",\n    value: function end(buf, enc) {\n      if (buf) this.write(buf, enc);\n      this[_ended] = true; // synthetic after-write logic, where drain/finish live\n\n      if (!this[_writing] && !this[_queue].length && typeof this[_fd] === 'number') this[_onwrite](null, 0);\n      return this;\n    }\n  }, {\n    key: \"write\",\n    value: function write(buf, enc) {\n      if (typeof buf === 'string') buf = Buffer.from(buf, enc);\n\n      if (this[_ended]) {\n        this.emit('error', new Error('write() after end()'));\n        return false;\n      }\n\n      if (this[_fd] === null || this[_writing] || this[_queue].length) {\n        this[_queue].push(buf);\n\n        this[_needDrain] = true;\n        return false;\n      }\n\n      this[_writing] = true;\n\n      this[_write](buf);\n\n      return true;\n    }\n  }, {\n    key: _write,\n    value: function value(buf) {\n      var _this7 = this;\n\n      fs.write(this[_fd], buf, 0, buf.length, this[_pos], function (er, bw) {\n        return _this7[_onwrite](er, bw);\n      });\n    }\n  }, {\n    key: _onwrite,\n    value: function value(er, bw) {\n      if (er) this[_onerror](er);else {\n        if (this[_pos] !== null) this[_pos] += bw;\n        if (this[_queue].length) this[_flush]();else {\n          this[_writing] = false;\n\n          if (this[_ended] && !this[_finished]) {\n            this[_finished] = true;\n\n            this[_close]();\n\n            this.emit('finish');\n          } else if (this[_needDrain]) {\n            this[_needDrain] = false;\n            this.emit('drain');\n          }\n        }\n      }\n    }\n  }, {\n    key: _flush,\n    value: function value() {\n      var _this8 = this;\n\n      if (this[_queue].length === 0) {\n        if (this[_ended]) this[_onwrite](null, 0);\n      } else if (this[_queue].length === 1) this[_write](this[_queue].pop());else {\n        var iovec = this[_queue];\n        this[_queue] = [];\n        writev(this[_fd], iovec, this[_pos], function (er, bw) {\n          return _this8[_onwrite](er, bw);\n        });\n      }\n    }\n  }, {\n    key: _close,\n    value: function value() {\n      var _this9 = this;\n\n      if (this[_autoClose] && typeof this[_fd] === 'number') {\n        var fd = this[_fd];\n        this[_fd] = null;\n        fs.close(fd, function (er) {\n          return er ? _this9.emit('error', er) : _this9.emit('close');\n        });\n      }\n    }\n  }]);\n\n  return WriteStream;\n}(EE);\n\nvar WriteStreamSync = /*#__PURE__*/function (_WriteStream) {\n  _inherits(WriteStreamSync, _WriteStream);\n\n  var _super4 = _createSuper(WriteStreamSync);\n\n  function WriteStreamSync() {\n    _classCallCheck(this, WriteStreamSync);\n\n    return _super4.apply(this, arguments);\n  }\n\n  _createClass(WriteStreamSync, [{\n    key: _open,\n    value: function value() {\n      var fd; // only wrap in a try{} block if we know we'll retry, to avoid\n      // the rethrow obscuring the error's source frame in most cases.\n\n      if (this[_defaultFlag] && this[_flags] === 'r+') {\n        try {\n          fd = fs.openSync(this[_path], this[_flags], this[_mode]);\n        } catch (er) {\n          if (er.code === 'ENOENT') {\n            this[_flags] = 'w';\n            return this[_open]();\n          } else throw er;\n        }\n      } else fd = fs.openSync(this[_path], this[_flags], this[_mode]);\n\n      this[_onopen](null, fd);\n    }\n  }, {\n    key: _close,\n    value: function value() {\n      if (this[_autoClose] && typeof this[_fd] === 'number') {\n        var fd = this[_fd];\n        this[_fd] = null;\n        fs.closeSync(fd);\n        this.emit('close');\n      }\n    }\n  }, {\n    key: _write,\n    value: function value(buf) {\n      // throw the original, but try to close if it fails\n      var threw = true;\n\n      try {\n        this[_onwrite](null, fs.writeSync(this[_fd], buf, 0, buf.length, this[_pos]));\n\n        threw = false;\n      } finally {\n        if (threw) try {\n          this[_close]();\n        } catch (_) {}\n      }\n    }\n  }]);\n\n  return WriteStreamSync;\n}(WriteStream);\n\nexports.ReadStream = ReadStream;\nexports.ReadStreamSync = ReadStreamSync;\nexports.WriteStream = WriteStream;\nexports.WriteStreamSync = WriteStreamSync;","map":{"version":3,"sources":["/Users/austenhughes/The-Baffoonery/node_modules/fs-minipass/index.js"],"names":["MiniPass","require","EE","EventEmitter","fs","writev","binding","process","FSReqWrap","FSReqCallback","fd","iovec","pos","cb","done","er","bw","req","oncomplete","writeBuffers","_autoClose","Symbol","_close","_ended","_fd","_finished","_flags","_flush","_handleChunk","_makeBuf","_mode","_needDrain","_onerror","_onopen","_onread","_onwrite","_open","_path","_pos","_queue","_read","_readSize","_reading","_remain","_size","_write","_writing","_defaultFlag","_errored","ReadStream","path","opt","readable","writable","TypeError","readSize","size","Infinity","autoClose","open","emit","Buffer","allocUnsafe","Math","min","buf","length","nextTick","read","br","close","ret","slice","ev","data","ReadStreamSync","threw","openSync","readSync","closeSync","WriteStream","mode","undefined","start","defaultFlag","flags","code","enc","write","from","Error","push","pop","WriteStreamSync","writeSync","_","exports"],"mappings":"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","sourcesContent":["'use strict'\nconst MiniPass = require('minipass')\nconst EE = require('events').EventEmitter\nconst fs = require('fs')\n\nlet writev = fs.writev\n/* istanbul ignore next */\nif (!writev) {\n  // This entire block can be removed if support for earlier than Node.js\n  // 12.9.0 is not needed.\n  const binding = process.binding('fs')\n  const FSReqWrap = binding.FSReqWrap || binding.FSReqCallback\n\n  writev = (fd, iovec, pos, cb) => {\n    const done = (er, bw) => cb(er, bw, iovec)\n    const req = new FSReqWrap()\n    req.oncomplete = done\n    binding.writeBuffers(fd, iovec, pos, req)\n  }\n}\n\nconst _autoClose = Symbol('_autoClose')\nconst _close = Symbol('_close')\nconst _ended = Symbol('_ended')\nconst _fd = Symbol('_fd')\nconst _finished = Symbol('_finished')\nconst _flags = Symbol('_flags')\nconst _flush = Symbol('_flush')\nconst _handleChunk = Symbol('_handleChunk')\nconst _makeBuf = Symbol('_makeBuf')\nconst _mode = Symbol('_mode')\nconst _needDrain = Symbol('_needDrain')\nconst _onerror = Symbol('_onerror')\nconst _onopen = Symbol('_onopen')\nconst _onread = Symbol('_onread')\nconst _onwrite = Symbol('_onwrite')\nconst _open = Symbol('_open')\nconst _path = Symbol('_path')\nconst _pos = Symbol('_pos')\nconst _queue = Symbol('_queue')\nconst _read = Symbol('_read')\nconst _readSize = Symbol('_readSize')\nconst _reading = Symbol('_reading')\nconst _remain = Symbol('_remain')\nconst _size = Symbol('_size')\nconst _write = Symbol('_write')\nconst _writing = Symbol('_writing')\nconst _defaultFlag = Symbol('_defaultFlag')\nconst _errored = Symbol('_errored')\n\nclass ReadStream extends MiniPass {\n  constructor (path, opt) {\n    opt = opt || {}\n    super(opt)\n\n    this.readable = true\n    this.writable = false\n\n    if (typeof path !== 'string')\n      throw new TypeError('path must be a string')\n\n    this[_errored] = false\n    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null\n    this[_path] = path\n    this[_readSize] = opt.readSize || 16*1024*1024\n    this[_reading] = false\n    this[_size] = typeof opt.size === 'number' ? opt.size : Infinity\n    this[_remain] = this[_size]\n    this[_autoClose] = typeof opt.autoClose === 'boolean' ?\n      opt.autoClose : true\n\n    if (typeof this[_fd] === 'number')\n      this[_read]()\n    else\n      this[_open]()\n  }\n\n  get fd () { return this[_fd] }\n  get path () { return this[_path] }\n\n  write () {\n    throw new TypeError('this is a readable stream')\n  }\n\n  end () {\n    throw new TypeError('this is a readable stream')\n  }\n\n  [_open] () {\n    fs.open(this[_path], 'r', (er, fd) => this[_onopen](er, fd))\n  }\n\n  [_onopen] (er, fd) {\n    if (er)\n      this[_onerror](er)\n    else {\n      this[_fd] = fd\n      this.emit('open', fd)\n      this[_read]()\n    }\n  }\n\n  [_makeBuf] () {\n    return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]))\n  }\n\n  [_read] () {\n    if (!this[_reading]) {\n      this[_reading] = true\n      const buf = this[_makeBuf]()\n      /* istanbul ignore if */\n      if (buf.length === 0)\n        return process.nextTick(() => this[_onread](null, 0, buf))\n      fs.read(this[_fd], buf, 0, buf.length, null, (er, br, buf) =>\n        this[_onread](er, br, buf))\n    }\n  }\n\n  [_onread] (er, br, buf) {\n    this[_reading] = false\n    if (er)\n      this[_onerror](er)\n    else if (this[_handleChunk](br, buf))\n      this[_read]()\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd]\n      this[_fd] = null\n      fs.close(fd, er => er ? this.emit('error', er) : this.emit('close'))\n    }\n  }\n\n  [_onerror] (er) {\n    this[_reading] = true\n    this[_close]()\n    this.emit('error', er)\n  }\n\n  [_handleChunk] (br, buf) {\n    let ret = false\n    // no effect if infinite\n    this[_remain] -= br\n    if (br > 0)\n      ret = super.write(br < buf.length ? buf.slice(0, br) : buf)\n\n    if (br === 0 || this[_remain] <= 0) {\n      ret = false\n      this[_close]()\n      super.end()\n    }\n\n    return ret\n  }\n\n  emit (ev, data) {\n    switch (ev) {\n      case 'prefinish':\n      case 'finish':\n        break\n\n      case 'drain':\n        if (typeof this[_fd] === 'number')\n          this[_read]()\n        break\n\n      case 'error':\n        if (this[_errored])\n          return\n        this[_errored] = true\n        return super.emit(ev, data)\n\n      default:\n        return super.emit(ev, data)\n    }\n  }\n}\n\nclass ReadStreamSync extends ReadStream {\n  [_open] () {\n    let threw = true\n    try {\n      this[_onopen](null, fs.openSync(this[_path], 'r'))\n      threw = false\n    } finally {\n      if (threw)\n        this[_close]()\n    }\n  }\n\n  [_read] () {\n    let threw = true\n    try {\n      if (!this[_reading]) {\n        this[_reading] = true\n        do {\n          const buf = this[_makeBuf]()\n          /* istanbul ignore next */\n          const br = buf.length === 0 ? 0\n            : fs.readSync(this[_fd], buf, 0, buf.length, null)\n          if (!this[_handleChunk](br, buf))\n            break\n        } while (true)\n        this[_reading] = false\n      }\n      threw = false\n    } finally {\n      if (threw)\n        this[_close]()\n    }\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd]\n      this[_fd] = null\n      fs.closeSync(fd)\n      this.emit('close')\n    }\n  }\n}\n\nclass WriteStream extends EE {\n  constructor (path, opt) {\n    opt = opt || {}\n    super(opt)\n    this.readable = false\n    this.writable = true\n    this[_errored] = false\n    this[_writing] = false\n    this[_ended] = false\n    this[_needDrain] = false\n    this[_queue] = []\n    this[_path] = path\n    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null\n    this[_mode] = opt.mode === undefined ? 0o666 : opt.mode\n    this[_pos] = typeof opt.start === 'number' ? opt.start : null\n    this[_autoClose] = typeof opt.autoClose === 'boolean' ?\n      opt.autoClose : true\n\n    // truncating makes no sense when writing into the middle\n    const defaultFlag = this[_pos] !== null ? 'r+' : 'w'\n    this[_defaultFlag] = opt.flags === undefined\n    this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags\n\n    if (this[_fd] === null)\n      this[_open]()\n  }\n\n  emit (ev, data) {\n    if (ev === 'error') {\n      if (this[_errored])\n        return\n      this[_errored] = true\n    }\n    return super.emit(ev, data)\n  }\n\n\n  get fd () { return this[_fd] }\n  get path () { return this[_path] }\n\n  [_onerror] (er) {\n    this[_close]()\n    this[_writing] = true\n    this.emit('error', er)\n  }\n\n  [_open] () {\n    fs.open(this[_path], this[_flags], this[_mode],\n      (er, fd) => this[_onopen](er, fd))\n  }\n\n  [_onopen] (er, fd) {\n    if (this[_defaultFlag] &&\n        this[_flags] === 'r+' &&\n        er && er.code === 'ENOENT') {\n      this[_flags] = 'w'\n      this[_open]()\n    } else if (er)\n      this[_onerror](er)\n    else {\n      this[_fd] = fd\n      this.emit('open', fd)\n      this[_flush]()\n    }\n  }\n\n  end (buf, enc) {\n    if (buf)\n      this.write(buf, enc)\n\n    this[_ended] = true\n\n    // synthetic after-write logic, where drain/finish live\n    if (!this[_writing] && !this[_queue].length &&\n        typeof this[_fd] === 'number')\n      this[_onwrite](null, 0)\n    return this\n  }\n\n  write (buf, enc) {\n    if (typeof buf === 'string')\n      buf = Buffer.from(buf, enc)\n\n    if (this[_ended]) {\n      this.emit('error', new Error('write() after end()'))\n      return false\n    }\n\n    if (this[_fd] === null || this[_writing] || this[_queue].length) {\n      this[_queue].push(buf)\n      this[_needDrain] = true\n      return false\n    }\n\n    this[_writing] = true\n    this[_write](buf)\n    return true\n  }\n\n  [_write] (buf) {\n    fs.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) =>\n      this[_onwrite](er, bw))\n  }\n\n  [_onwrite] (er, bw) {\n    if (er)\n      this[_onerror](er)\n    else {\n      if (this[_pos] !== null)\n        this[_pos] += bw\n      if (this[_queue].length)\n        this[_flush]()\n      else {\n        this[_writing] = false\n\n        if (this[_ended] && !this[_finished]) {\n          this[_finished] = true\n          this[_close]()\n          this.emit('finish')\n        } else if (this[_needDrain]) {\n          this[_needDrain] = false\n          this.emit('drain')\n        }\n      }\n    }\n  }\n\n  [_flush] () {\n    if (this[_queue].length === 0) {\n      if (this[_ended])\n        this[_onwrite](null, 0)\n    } else if (this[_queue].length === 1)\n      this[_write](this[_queue].pop())\n    else {\n      const iovec = this[_queue]\n      this[_queue] = []\n      writev(this[_fd], iovec, this[_pos],\n        (er, bw) => this[_onwrite](er, bw))\n    }\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd]\n      this[_fd] = null\n      fs.close(fd, er => er ? this.emit('error', er) : this.emit('close'))\n    }\n  }\n}\n\nclass WriteStreamSync extends WriteStream {\n  [_open] () {\n    let fd\n    // only wrap in a try{} block if we know we'll retry, to avoid\n    // the rethrow obscuring the error's source frame in most cases.\n    if (this[_defaultFlag] && this[_flags] === 'r+') {\n      try {\n        fd = fs.openSync(this[_path], this[_flags], this[_mode])\n      } catch (er) {\n        if (er.code === 'ENOENT') {\n          this[_flags] = 'w'\n          return this[_open]()\n        } else\n          throw er\n      }\n    } else\n      fd = fs.openSync(this[_path], this[_flags], this[_mode])\n\n    this[_onopen](null, fd)\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd]\n      this[_fd] = null\n      fs.closeSync(fd)\n      this.emit('close')\n    }\n  }\n\n  [_write] (buf) {\n    // throw the original, but try to close if it fails\n    let threw = true\n    try {\n      this[_onwrite](null,\n        fs.writeSync(this[_fd], buf, 0, buf.length, this[_pos]))\n      threw = false\n    } finally {\n      if (threw)\n        try { this[_close]() } catch (_) {}\n    }\n  }\n}\n\nexports.ReadStream = ReadStream\nexports.ReadStreamSync = ReadStreamSync\n\nexports.WriteStream = WriteStream\nexports.WriteStreamSync = WriteStreamSync\n"]},"metadata":{},"sourceType":"script"}