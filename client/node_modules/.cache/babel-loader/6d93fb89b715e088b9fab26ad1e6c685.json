{"ast":null,"code":"var _require = require('path'),\n    dirname = _require.dirname;\n\nvar mkdirpManual = function mkdirpManual(path, opts, made) {\n  opts.recursive = false;\n  var parent = dirname(path);\n\n  if (parent === path) {\n    return opts.mkdirAsync(path, opts).catch(function (er) {\n      // swallowed by recursive implementation on posix systems\n      // any other error is a failure\n      if (er.code !== 'EISDIR') throw er;\n    });\n  }\n\n  return opts.mkdirAsync(path, opts).then(function () {\n    return made || path;\n  }, function (er) {\n    if (er.code === 'ENOENT') return mkdirpManual(parent, opts).then(function (made) {\n      return mkdirpManual(path, opts, made);\n    });\n    if (er.code !== 'EEXIST' && er.code !== 'EROFS') throw er;\n    return opts.statAsync(path).then(function (st) {\n      if (st.isDirectory()) return made;else throw er;\n    }, function () {\n      throw er;\n    });\n  });\n};\n\nvar mkdirpManualSync = function mkdirpManualSync(path, opts, made) {\n  var parent = dirname(path);\n  opts.recursive = false;\n\n  if (parent === path) {\n    try {\n      return opts.mkdirSync(path, opts);\n    } catch (er) {\n      // swallowed by recursive implementation on posix systems\n      // any other error is a failure\n      if (er.code !== 'EISDIR') throw er;else return;\n    }\n  }\n\n  try {\n    opts.mkdirSync(path, opts);\n    return made || path;\n  } catch (er) {\n    if (er.code === 'ENOENT') return mkdirpManualSync(path, opts, mkdirpManualSync(parent, opts, made));\n    if (er.code !== 'EEXIST' && er.code !== 'EROFS') throw er;\n\n    try {\n      if (!opts.statSync(path).isDirectory()) throw er;\n    } catch (_) {\n      throw er;\n    }\n  }\n};\n\nmodule.exports = {\n  mkdirpManual: mkdirpManual,\n  mkdirpManualSync: mkdirpManualSync\n};","map":{"version":3,"sources":["/Users/austenhughes/The-Baffoonery/node_modules/mkdirp/lib/mkdirp-manual.js"],"names":["require","dirname","mkdirpManual","path","opts","made","recursive","parent","mkdirAsync","catch","er","code","then","statAsync","st","isDirectory","mkdirpManualSync","mkdirSync","statSync","_","module","exports"],"mappings":"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","sourcesContent":["const {dirname} = require('path')\n\nconst mkdirpManual = (path, opts, made) => {\n  opts.recursive = false\n  const parent = dirname(path)\n  if (parent === path) {\n    return opts.mkdirAsync(path, opts).catch(er => {\n      // swallowed by recursive implementation on posix systems\n      // any other error is a failure\n      if (er.code !== 'EISDIR')\n        throw er\n    })\n  }\n\n  return opts.mkdirAsync(path, opts).then(() => made || path, er => {\n    if (er.code === 'ENOENT')\n      return mkdirpManual(parent, opts)\n        .then(made => mkdirpManual(path, opts, made))\n    if (er.code !== 'EEXIST' && er.code !== 'EROFS')\n      throw er\n    return opts.statAsync(path).then(st => {\n      if (st.isDirectory())\n        return made\n      else\n        throw er\n    }, () => { throw er })\n  })\n}\n\nconst mkdirpManualSync = (path, opts, made) => {\n  const parent = dirname(path)\n  opts.recursive = false\n\n  if (parent === path) {\n    try {\n      return opts.mkdirSync(path, opts)\n    } catch (er) {\n      // swallowed by recursive implementation on posix systems\n      // any other error is a failure\n      if (er.code !== 'EISDIR')\n        throw er\n      else\n        return\n    }\n  }\n\n  try {\n    opts.mkdirSync(path, opts)\n    return made || path\n  } catch (er) {\n    if (er.code === 'ENOENT')\n      return mkdirpManualSync(path, opts, mkdirpManualSync(parent, opts, made))\n    if (er.code !== 'EEXIST' && er.code !== 'EROFS')\n      throw er\n    try {\n      if (!opts.statSync(path).isDirectory())\n        throw er\n    } catch (_) {\n      throw er\n    }\n  }\n}\n\nmodule.exports = {mkdirpManual, mkdirpManualSync}\n"]},"metadata":{},"sourceType":"script"}