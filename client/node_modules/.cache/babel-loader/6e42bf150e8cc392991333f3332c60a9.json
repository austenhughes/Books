{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar MiniPass = require('minipass');\n\nvar SLURP = Symbol('slurp');\n\nmodule.exports = /*#__PURE__*/function (_MiniPass) {\n  _inherits(ReadEntry, _MiniPass);\n\n  var _super = _createSuper(ReadEntry);\n\n  function ReadEntry(header, ex, gex) {\n    var _this;\n\n    _classCallCheck(this, ReadEntry);\n\n    _this = _super.call(this); // read entries always start life paused.  this is to avoid the\n    // situation where Minipass's auto-ending empty streams results\n    // in an entry ending before we're ready for it.\n\n    _this.pause();\n\n    _this.extended = ex;\n    _this.globalExtended = gex;\n    _this.header = header;\n    _this.startBlockSize = 512 * Math.ceil(header.size / 512);\n    _this.blockRemain = _this.startBlockSize;\n    _this.remain = header.size;\n    _this.type = header.type;\n    _this.meta = false;\n    _this.ignore = false;\n\n    switch (_this.type) {\n      case 'File':\n      case 'OldFile':\n      case 'Link':\n      case 'SymbolicLink':\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'Directory':\n      case 'FIFO':\n      case 'ContiguousFile':\n      case 'GNUDumpDir':\n        break;\n\n      case 'NextFileHasLongLinkpath':\n      case 'NextFileHasLongPath':\n      case 'OldGnuLongPath':\n      case 'GlobalExtendedHeader':\n      case 'ExtendedHeader':\n      case 'OldExtendedHeader':\n        _this.meta = true;\n        break;\n      // NOTE: gnutar and bsdtar treat unrecognized types as 'File'\n      // it may be worth doing the same, but with a warning.\n\n      default:\n        _this.ignore = true;\n    }\n\n    _this.path = header.path;\n    _this.mode = header.mode;\n    if (_this.mode) _this.mode = _this.mode & 4095;\n    _this.uid = header.uid;\n    _this.gid = header.gid;\n    _this.uname = header.uname;\n    _this.gname = header.gname;\n    _this.size = header.size;\n    _this.mtime = header.mtime;\n    _this.atime = header.atime;\n    _this.ctime = header.ctime;\n    _this.linkpath = header.linkpath;\n    _this.uname = header.uname;\n    _this.gname = header.gname;\n    if (ex) _this[SLURP](ex);\n    if (gex) _this[SLURP](gex, true);\n    return _this;\n  }\n\n  _createClass(ReadEntry, [{\n    key: \"write\",\n    value: function write(data) {\n      var writeLen = data.length;\n      if (writeLen > this.blockRemain) throw new Error('writing more to entry than is appropriate');\n      var r = this.remain;\n      var br = this.blockRemain;\n      this.remain = Math.max(0, r - writeLen);\n      this.blockRemain = Math.max(0, br - writeLen);\n      if (this.ignore) return true;\n      if (r >= writeLen) return _get(_getPrototypeOf(ReadEntry.prototype), \"write\", this).call(this, data); // r < writeLen\n\n      return _get(_getPrototypeOf(ReadEntry.prototype), \"write\", this).call(this, data.slice(0, r));\n    }\n  }, {\n    key: SLURP,\n    value: function value(ex, global) {\n      for (var k in ex) {\n        // we slurp in everything except for the path attribute in\n        // a global extended header, because that's weird.\n        if (ex[k] !== null && ex[k] !== undefined && !(global && k === 'path')) this[k] = ex[k];\n      }\n    }\n  }]);\n\n  return ReadEntry;\n}(MiniPass);","map":{"version":3,"sources":["/Users/austenhughes/The-Baffoonery/node_modules/tar/lib/read-entry.js"],"names":["MiniPass","require","SLURP","Symbol","module","exports","header","ex","gex","pause","extended","globalExtended","startBlockSize","Math","ceil","size","blockRemain","remain","type","meta","ignore","path","mode","uid","gid","uname","gname","mtime","atime","ctime","linkpath","data","writeLen","length","Error","r","br","max","slice","global","k","undefined"],"mappings":"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","sourcesContent":["'use strict'\nconst MiniPass = require('minipass')\n\nconst SLURP = Symbol('slurp')\nmodule.exports = class ReadEntry extends MiniPass {\n  constructor (header, ex, gex) {\n    super()\n    // read entries always start life paused.  this is to avoid the\n    // situation where Minipass's auto-ending empty streams results\n    // in an entry ending before we're ready for it.\n    this.pause()\n    this.extended = ex\n    this.globalExtended = gex\n    this.header = header\n    this.startBlockSize = 512 * Math.ceil(header.size / 512)\n    this.blockRemain = this.startBlockSize\n    this.remain = header.size\n    this.type = header.type\n    this.meta = false\n    this.ignore = false\n    switch (this.type) {\n      case 'File':\n      case 'OldFile':\n      case 'Link':\n      case 'SymbolicLink':\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'Directory':\n      case 'FIFO':\n      case 'ContiguousFile':\n      case 'GNUDumpDir':\n        break\n\n      case 'NextFileHasLongLinkpath':\n      case 'NextFileHasLongPath':\n      case 'OldGnuLongPath':\n      case 'GlobalExtendedHeader':\n      case 'ExtendedHeader':\n      case 'OldExtendedHeader':\n        this.meta = true\n        break\n\n      // NOTE: gnutar and bsdtar treat unrecognized types as 'File'\n      // it may be worth doing the same, but with a warning.\n      default:\n        this.ignore = true\n    }\n\n    this.path = header.path\n    this.mode = header.mode\n    if (this.mode)\n      this.mode = this.mode & 0o7777\n    this.uid = header.uid\n    this.gid = header.gid\n    this.uname = header.uname\n    this.gname = header.gname\n    this.size = header.size\n    this.mtime = header.mtime\n    this.atime = header.atime\n    this.ctime = header.ctime\n    this.linkpath = header.linkpath\n    this.uname = header.uname\n    this.gname = header.gname\n\n    if (ex)\n      this[SLURP](ex)\n    if (gex)\n      this[SLURP](gex, true)\n  }\n\n  write (data) {\n    const writeLen = data.length\n    if (writeLen > this.blockRemain)\n      throw new Error('writing more to entry than is appropriate')\n\n    const r = this.remain\n    const br = this.blockRemain\n    this.remain = Math.max(0, r - writeLen)\n    this.blockRemain = Math.max(0, br - writeLen)\n    if (this.ignore)\n      return true\n\n    if (r >= writeLen)\n      return super.write(data)\n\n    // r < writeLen\n    return super.write(data.slice(0, r))\n  }\n\n  [SLURP] (ex, global) {\n    for (const k in ex) {\n      // we slurp in everything except for the path attribute in\n      // a global extended header, because that's weird.\n      if (ex[k] !== null && ex[k] !== undefined &&\n          !(global && k === 'path'))\n        this[k] = ex[k]\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}