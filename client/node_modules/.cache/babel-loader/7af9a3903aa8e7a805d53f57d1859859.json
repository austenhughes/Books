{"ast":null,"code":"'use strict'; // tar -x\n\nvar hlo = require('./high-level-opt.js');\n\nvar Unpack = require('./unpack.js');\n\nvar fs = require('fs');\n\nvar fsm = require('fs-minipass');\n\nvar path = require('path');\n\nmodule.exports = function (opt_, files, cb) {\n  if (typeof opt_ === 'function') cb = opt_, files = null, opt_ = {};else if (Array.isArray(opt_)) files = opt_, opt_ = {};\n  if (typeof files === 'function') cb = files, files = null;\n  if (!files) files = [];else files = Array.from(files);\n  var opt = hlo(opt_);\n  if (opt.sync && typeof cb === 'function') throw new TypeError('callback not supported for sync tar functions');\n  if (!opt.file && typeof cb === 'function') throw new TypeError('callback only supported with file option');\n  if (files.length) filesFilter(opt, files);\n  return opt.file && opt.sync ? extractFileSync(opt) : opt.file ? extractFile(opt, cb) : opt.sync ? extractSync(opt) : extract(opt);\n}; // construct a filter that limits the file entries listed\n// include child entries if a dir is included\n\n\nvar filesFilter = function filesFilter(opt, files) {\n  var map = new Map(files.map(function (f) {\n    return [f.replace(/\\/+$/, ''), true];\n  }));\n  var filter = opt.filter;\n\n  var mapHas = function mapHas(file, r) {\n    var root = r || path.parse(file).root || '.';\n    var ret = file === root ? false : map.has(file) ? map.get(file) : mapHas(path.dirname(file), root);\n    map.set(file, ret);\n    return ret;\n  };\n\n  opt.filter = filter ? function (file, entry) {\n    return filter(file, entry) && mapHas(file.replace(/\\/+$/, ''));\n  } : function (file) {\n    return mapHas(file.replace(/\\/+$/, ''));\n  };\n};\n\nvar extractFileSync = function extractFileSync(opt) {\n  var u = new Unpack.Sync(opt);\n  var file = opt.file;\n  var stat = fs.statSync(file); // This trades a zero-byte read() syscall for a stat\n  // However, it will usually result in less memory allocation\n\n  var readSize = opt.maxReadSize || 16 * 1024 * 1024;\n  var stream = new fsm.ReadStreamSync(file, {\n    readSize: readSize,\n    size: stat.size\n  });\n  stream.pipe(u);\n};\n\nvar extractFile = function extractFile(opt, cb) {\n  var u = new Unpack(opt);\n  var readSize = opt.maxReadSize || 16 * 1024 * 1024;\n  var file = opt.file;\n  var p = new Promise(function (resolve, reject) {\n    u.on('error', reject);\n    u.on('close', resolve); // This trades a zero-byte read() syscall for a stat\n    // However, it will usually result in less memory allocation\n\n    fs.stat(file, function (er, stat) {\n      if (er) reject(er);else {\n        var stream = new fsm.ReadStream(file, {\n          readSize: readSize,\n          size: stat.size\n        });\n        stream.on('error', reject);\n        stream.pipe(u);\n      }\n    });\n  });\n  return cb ? p.then(cb, cb) : p;\n};\n\nvar extractSync = function extractSync(opt) {\n  return new Unpack.Sync(opt);\n};\n\nvar extract = function extract(opt) {\n  return new Unpack(opt);\n};","map":{"version":3,"sources":["/Users/austenhughes/The-Baffoonery/node_modules/tar/lib/extract.js"],"names":["hlo","require","Unpack","fs","fsm","path","module","exports","opt_","files","cb","Array","isArray","from","opt","sync","TypeError","file","length","filesFilter","extractFileSync","extractFile","extractSync","extract","map","Map","f","replace","filter","mapHas","r","root","parse","ret","has","get","dirname","set","entry","u","Sync","stat","statSync","readSize","maxReadSize","stream","ReadStreamSync","size","pipe","p","Promise","resolve","reject","on","er","ReadStream","then"],"mappings":"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","sourcesContent":["'use strict'\n\n// tar -x\nconst hlo = require('./high-level-opt.js')\nconst Unpack = require('./unpack.js')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst path = require('path')\n\nmodule.exports = (opt_, files, cb) => {\n  if (typeof opt_ === 'function')\n    cb = opt_, files = null, opt_ = {}\n  else if (Array.isArray(opt_))\n    files = opt_, opt_ = {}\n\n  if (typeof files === 'function')\n    cb = files, files = null\n\n  if (!files)\n    files = []\n  else\n    files = Array.from(files)\n\n  const opt = hlo(opt_)\n\n  if (opt.sync && typeof cb === 'function')\n    throw new TypeError('callback not supported for sync tar functions')\n\n  if (!opt.file && typeof cb === 'function')\n    throw new TypeError('callback only supported with file option')\n\n  if (files.length)\n    filesFilter(opt, files)\n\n  return opt.file && opt.sync ? extractFileSync(opt)\n    : opt.file ? extractFile(opt, cb)\n    : opt.sync ? extractSync(opt)\n    : extract(opt)\n}\n\n// construct a filter that limits the file entries listed\n// include child entries if a dir is included\nconst filesFilter = (opt, files) => {\n  const map = new Map(files.map(f => [f.replace(/\\/+$/, ''), true]))\n  const filter = opt.filter\n\n  const mapHas = (file, r) => {\n    const root = r || path.parse(file).root || '.'\n    const ret = file === root ? false\n      : map.has(file) ? map.get(file)\n      : mapHas(path.dirname(file), root)\n\n    map.set(file, ret)\n    return ret\n  }\n\n  opt.filter = filter\n    ? (file, entry) => filter(file, entry) && mapHas(file.replace(/\\/+$/, ''))\n    : file => mapHas(file.replace(/\\/+$/, ''))\n}\n\nconst extractFileSync = opt => {\n  const u = new Unpack.Sync(opt)\n\n  const file = opt.file\n  const stat = fs.statSync(file)\n  // This trades a zero-byte read() syscall for a stat\n  // However, it will usually result in less memory allocation\n  const readSize = opt.maxReadSize || 16 * 1024 * 1024\n  const stream = new fsm.ReadStreamSync(file, {\n    readSize: readSize,\n    size: stat.size,\n  })\n  stream.pipe(u)\n}\n\nconst extractFile = (opt, cb) => {\n  const u = new Unpack(opt)\n  const readSize = opt.maxReadSize || 16 * 1024 * 1024\n\n  const file = opt.file\n  const p = new Promise((resolve, reject) => {\n    u.on('error', reject)\n    u.on('close', resolve)\n\n    // This trades a zero-byte read() syscall for a stat\n    // However, it will usually result in less memory allocation\n    fs.stat(file, (er, stat) => {\n      if (er)\n        reject(er)\n      else {\n        const stream = new fsm.ReadStream(file, {\n          readSize: readSize,\n          size: stat.size,\n        })\n        stream.on('error', reject)\n        stream.pipe(u)\n      }\n    })\n  })\n  return cb ? p.then(cb, cb) : p\n}\n\nconst extractSync = opt => new Unpack.Sync(opt)\n\nconst extract = opt => new Unpack(opt)\n"]},"metadata":{},"sourceType":"script"}