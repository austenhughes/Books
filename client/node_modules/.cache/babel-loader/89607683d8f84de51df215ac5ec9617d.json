{"ast":null,"code":"var _toConsumableArray = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\n// A path exclusive reservation system\n// reserve([list, of, paths], fn)\n// When the fn is first in line for all its paths, it\n// is called with a cb that clears the reservation.\n//\n// Used by async unpack to avoid clobbering paths in use,\n// while still allowing maximal safe parallelization.\nvar assert = require('assert');\n\nmodule.exports = function () {\n  // path => [function or Set]\n  // A Set object means a directory reservation\n  // A fn is a direct reservation on that path\n  var queues = new Map(); // fn => {paths:[path,...], dirs:[path, ...]}\n\n  var reservations = new Map(); // return a set of parent dirs for a given path\n\n  var _require = require('path'),\n      join = _require.join;\n\n  var getDirs = function getDirs(path) {\n    return join(path).split(/[\\\\/]/).slice(0, -1).reduce(function (set, path) {\n      return set.length ? set.concat(join(set[set.length - 1], path)) : [path];\n    }, []);\n  }; // functions currently running\n\n\n  var running = new Set(); // return the queues for each path the function cares about\n  // fn => {paths, dirs}\n\n  var getQueues = function getQueues(fn) {\n    var res = reservations.get(fn);\n    /* istanbul ignore if - unpossible */\n\n    if (!res) throw new Error('function does not have any path reservations');\n    return {\n      paths: res.paths.map(function (path) {\n        return queues.get(path);\n      }),\n      dirs: _toConsumableArray(res.dirs).map(function (path) {\n        return queues.get(path);\n      })\n    };\n  }; // check if fn is first in line for all its paths, and is\n  // included in the first set for all its dir queues\n\n\n  var check = function check(fn) {\n    var _getQueues = getQueues(fn),\n        paths = _getQueues.paths,\n        dirs = _getQueues.dirs;\n\n    return paths.every(function (q) {\n      return q[0] === fn;\n    }) && dirs.every(function (q) {\n      return q[0] instanceof Set && q[0].has(fn);\n    });\n  }; // run the function if it's first in line and not already running\n\n\n  var run = function run(fn) {\n    if (running.has(fn) || !check(fn)) return false;\n    running.add(fn);\n    fn(function () {\n      return clear(fn);\n    });\n    return true;\n  };\n\n  var clear = function clear(fn) {\n    if (!running.has(fn)) return false;\n\n    var _reservations$get = reservations.get(fn),\n        paths = _reservations$get.paths,\n        dirs = _reservations$get.dirs;\n\n    var next = new Set();\n    paths.forEach(function (path) {\n      var q = queues.get(path);\n      assert.equal(q[0], fn);\n      if (q.length === 1) queues.delete(path);else {\n        q.shift();\n        if (typeof q[0] === 'function') next.add(q[0]);else q[0].forEach(function (fn) {\n          return next.add(fn);\n        });\n      }\n    });\n    dirs.forEach(function (dir) {\n      var q = queues.get(dir);\n      assert(q[0] instanceof Set);\n      if (q[0].size === 1 && q.length === 1) queues.delete(dir);else if (q[0].size === 1) {\n        q.shift(); // must be a function or else the Set would've been reused\n\n        next.add(q[0]);\n      } else q[0].delete(fn);\n    });\n    running.delete(fn);\n    next.forEach(function (fn) {\n      return run(fn);\n    });\n    return true;\n  };\n\n  var reserve = function reserve(paths, fn) {\n    var dirs = new Set(paths.map(function (path) {\n      return getDirs(path);\n    }).reduce(function (a, b) {\n      return a.concat(b);\n    }));\n    reservations.set(fn, {\n      dirs: dirs,\n      paths: paths\n    });\n    paths.forEach(function (path) {\n      var q = queues.get(path);\n      if (!q) queues.set(path, [fn]);else q.push(fn);\n    });\n    dirs.forEach(function (dir) {\n      var q = queues.get(dir);\n      if (!q) queues.set(dir, [new Set([fn])]);else if (q[q.length - 1] instanceof Set) q[q.length - 1].add(fn);else q.push(new Set([fn]));\n    });\n    return run(fn);\n  };\n\n  return {\n    check: check,\n    reserve: reserve\n  };\n};","map":{"version":3,"sources":["/Users/austenhughes/The-Baffoonery/node_modules/tar/lib/path-reservations.js"],"names":["assert","require","module","exports","queues","Map","reservations","join","getDirs","path","split","slice","reduce","set","length","concat","running","Set","getQueues","fn","res","get","Error","paths","map","dirs","check","every","q","has","run","add","clear","next","forEach","equal","delete","shift","dir","size","reserve","a","b","push"],"mappings":"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","sourcesContent":["// A path exclusive reservation system\n// reserve([list, of, paths], fn)\n// When the fn is first in line for all its paths, it\n// is called with a cb that clears the reservation.\n//\n// Used by async unpack to avoid clobbering paths in use,\n// while still allowing maximal safe parallelization.\n\nconst assert = require('assert')\n\nmodule.exports = () => {\n  // path => [function or Set]\n  // A Set object means a directory reservation\n  // A fn is a direct reservation on that path\n  const queues = new Map()\n\n  // fn => {paths:[path,...], dirs:[path, ...]}\n  const reservations = new Map()\n\n  // return a set of parent dirs for a given path\n  const { join } = require('path')\n  const getDirs = path =>\n    join(path).split(/[\\\\/]/).slice(0, -1).reduce((set, path) =>\n      set.length ? set.concat(join(set[set.length - 1], path)) : [path], [])\n\n  // functions currently running\n  const running = new Set()\n\n  // return the queues for each path the function cares about\n  // fn => {paths, dirs}\n  const getQueues = fn => {\n    const res = reservations.get(fn)\n    /* istanbul ignore if - unpossible */\n    if (!res)\n      throw new Error('function does not have any path reservations')\n    return {\n      paths: res.paths.map(path => queues.get(path)),\n      dirs: [...res.dirs].map(path => queues.get(path)),\n    }\n  }\n\n  // check if fn is first in line for all its paths, and is\n  // included in the first set for all its dir queues\n  const check = fn => {\n    const {paths, dirs} = getQueues(fn)\n    return paths.every(q => q[0] === fn) &&\n      dirs.every(q => q[0] instanceof Set && q[0].has(fn))\n  }\n\n  // run the function if it's first in line and not already running\n  const run = fn => {\n    if (running.has(fn) || !check(fn))\n      return false\n    running.add(fn)\n    fn(() => clear(fn))\n    return true\n  }\n\n  const clear = fn => {\n    if (!running.has(fn))\n      return false\n\n    const { paths, dirs } = reservations.get(fn)\n    const next = new Set()\n\n    paths.forEach(path => {\n      const q = queues.get(path)\n      assert.equal(q[0], fn)\n      if (q.length === 1)\n        queues.delete(path)\n      else {\n        q.shift()\n        if (typeof q[0] === 'function')\n          next.add(q[0])\n        else\n          q[0].forEach(fn => next.add(fn))\n      }\n    })\n\n    dirs.forEach(dir => {\n      const q = queues.get(dir)\n      assert(q[0] instanceof Set)\n      if (q[0].size === 1 && q.length === 1)\n        queues.delete(dir)\n      else if (q[0].size === 1) {\n        q.shift()\n\n        // must be a function or else the Set would've been reused\n        next.add(q[0])\n      } else\n        q[0].delete(fn)\n    })\n    running.delete(fn)\n\n    next.forEach(fn => run(fn))\n    return true\n  }\n\n  const reserve = (paths, fn) => {\n    const dirs = new Set(\n      paths.map(path => getDirs(path)).reduce((a, b) => a.concat(b))\n    )\n    reservations.set(fn, {dirs, paths})\n    paths.forEach(path => {\n      const q = queues.get(path)\n      if (!q)\n        queues.set(path, [fn])\n      else\n        q.push(fn)\n    })\n    dirs.forEach(dir => {\n      const q = queues.get(dir)\n      if (!q)\n        queues.set(dir, [new Set([fn])])\n      else if (q[q.length - 1] instanceof Set)\n        q[q.length - 1].add(fn)\n      else\n        q.push(new Set([fn]))\n    })\n\n    return run(fn)\n  }\n\n  return { check, reserve }\n}\n"]},"metadata":{},"sourceType":"script"}