{"ast":null,"code":"'use strict'; // A readable tar stream creator\n// Technically, this is a transform stream that you write paths into,\n// and tar format comes out of.\n// The `add()` method is like `write()` but returns this,\n// and end() return `this` as well, so you can\n// do `new Pack(opt).add('files').add('dir').end().pipe(output)\n// You could also do something like:\n// streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))\n\nvar _createClass = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _get = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _classCallCheck = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar PackJob = function PackJob(path, absolute) {\n  _classCallCheck(this, PackJob);\n\n  this.path = path || './';\n  this.absolute = absolute;\n  this.entry = null;\n  this.stat = null;\n  this.readdir = null;\n  this.pending = false;\n  this.ignore = false;\n  this.piped = false;\n};\n\nvar MiniPass = require('minipass');\n\nvar zlib = require('minizlib');\n\nvar ReadEntry = require('./read-entry.js');\n\nvar WriteEntry = require('./write-entry.js');\n\nvar WriteEntrySync = WriteEntry.Sync;\nvar WriteEntryTar = WriteEntry.Tar;\n\nvar Yallist = require('yallist');\n\nvar EOF = Buffer.alloc(1024);\nvar ONSTAT = Symbol('onStat');\nvar ENDED = Symbol('ended');\nvar QUEUE = Symbol('queue');\nvar CURRENT = Symbol('current');\nvar PROCESS = Symbol('process');\nvar PROCESSING = Symbol('processing');\nvar PROCESSJOB = Symbol('processJob');\nvar JOBS = Symbol('jobs');\nvar JOBDONE = Symbol('jobDone');\nvar ADDFSENTRY = Symbol('addFSEntry');\nvar ADDTARENTRY = Symbol('addTarEntry');\nvar STAT = Symbol('stat');\nvar READDIR = Symbol('readdir');\nvar ONREADDIR = Symbol('onreaddir');\nvar PIPE = Symbol('pipe');\nvar ENTRY = Symbol('entry');\nvar ENTRYOPT = Symbol('entryOpt');\nvar WRITEENTRYCLASS = Symbol('writeEntryClass');\nvar WRITE = Symbol('write');\nvar ONDRAIN = Symbol('ondrain');\n\nvar fs = require('fs');\n\nvar path = require('path');\n\nvar warner = require('./warn-mixin.js');\n\nvar Pack = warner( /*#__PURE__*/function (_MiniPass) {\n  _inherits(Pack, _MiniPass);\n\n  var _super = _createSuper(Pack);\n\n  function Pack(opt) {\n    var _thisSuper, _thisSuper2, _this;\n\n    _classCallCheck(this, Pack);\n\n    _this = _super.call(this, opt);\n    opt = opt || Object.create(null);\n    _this.opt = opt;\n    _this.file = opt.file || '';\n    _this.cwd = opt.cwd || process.cwd();\n    _this.maxReadSize = opt.maxReadSize;\n    _this.preservePaths = !!opt.preservePaths;\n    _this.strict = !!opt.strict;\n    _this.noPax = !!opt.noPax;\n    _this.prefix = (opt.prefix || '').replace(/(\\\\|\\/)+$/, '');\n    _this.linkCache = opt.linkCache || new Map();\n    _this.statCache = opt.statCache || new Map();\n    _this.readdirCache = opt.readdirCache || new Map();\n    _this[WRITEENTRYCLASS] = WriteEntry;\n    if (typeof opt.onwarn === 'function') _this.on('warn', opt.onwarn);\n    _this.portable = !!opt.portable;\n    _this.zip = null;\n\n    if (opt.gzip) {\n      if (typeof opt.gzip !== 'object') opt.gzip = {};\n      if (_this.portable) opt.gzip.portable = true;\n      _this.zip = new zlib.Gzip(opt.gzip);\n\n      _this.zip.on('data', function (chunk) {\n        return _get((_thisSuper = _assertThisInitialized(_this), _getPrototypeOf(Pack.prototype)), \"write\", _thisSuper).call(_thisSuper, chunk);\n      });\n\n      _this.zip.on('end', function (_) {\n        return _get((_thisSuper2 = _assertThisInitialized(_this), _getPrototypeOf(Pack.prototype)), \"end\", _thisSuper2).call(_thisSuper2);\n      });\n\n      _this.zip.on('drain', function (_) {\n        return _this[ONDRAIN]();\n      });\n\n      _this.on('resume', function (_) {\n        return _this.zip.resume();\n      });\n    } else _this.on('drain', _this[ONDRAIN]);\n\n    _this.noDirRecurse = !!opt.noDirRecurse;\n    _this.follow = !!opt.follow;\n    _this.noMtime = !!opt.noMtime;\n    _this.mtime = opt.mtime || null;\n    _this.filter = typeof opt.filter === 'function' ? opt.filter : function (_) {\n      return true;\n    };\n    _this[QUEUE] = new Yallist();\n    _this[JOBS] = 0;\n    _this.jobs = +opt.jobs || 4;\n    _this[PROCESSING] = false;\n    _this[ENDED] = false;\n    return _this;\n  }\n\n  _createClass(Pack, [{\n    key: WRITE,\n    value: function value(chunk) {\n      return _get(_getPrototypeOf(Pack.prototype), \"write\", this).call(this, chunk);\n    }\n  }, {\n    key: \"add\",\n    value: function add(path) {\n      this.write(path);\n      return this;\n    }\n  }, {\n    key: \"end\",\n    value: function end(path) {\n      if (path) this.write(path);\n      this[ENDED] = true;\n      this[PROCESS]();\n      return this;\n    }\n  }, {\n    key: \"write\",\n    value: function write(path) {\n      if (this[ENDED]) throw new Error('write after end');\n      if (path instanceof ReadEntry) this[ADDTARENTRY](path);else this[ADDFSENTRY](path);\n      return this.flowing;\n    }\n  }, {\n    key: ADDTARENTRY,\n    value: function value(p) {\n      var _this2 = this;\n\n      var absolute = path.resolve(this.cwd, p.path);\n      if (this.prefix) p.path = this.prefix + '/' + p.path.replace(/^\\.(\\/+|$)/, ''); // in this case, we don't have to wait for the stat\n\n      if (!this.filter(p.path, p)) p.resume();else {\n        var job = new PackJob(p.path, absolute, false);\n        job.entry = new WriteEntryTar(p, this[ENTRYOPT](job));\n        job.entry.on('end', function (_) {\n          return _this2[JOBDONE](job);\n        });\n        this[JOBS] += 1;\n        this[QUEUE].push(job);\n      }\n      this[PROCESS]();\n    }\n  }, {\n    key: ADDFSENTRY,\n    value: function value(p) {\n      var absolute = path.resolve(this.cwd, p);\n      if (this.prefix) p = this.prefix + '/' + p.replace(/^\\.(\\/+|$)/, '');\n      this[QUEUE].push(new PackJob(p, absolute));\n      this[PROCESS]();\n    }\n  }, {\n    key: STAT,\n    value: function value(job) {\n      var _this3 = this;\n\n      job.pending = true;\n      this[JOBS] += 1;\n      var stat = this.follow ? 'stat' : 'lstat';\n      fs[stat](job.absolute, function (er, stat) {\n        job.pending = false;\n        _this3[JOBS] -= 1;\n        if (er) _this3.emit('error', er);else _this3[ONSTAT](job, stat);\n      });\n    }\n  }, {\n    key: ONSTAT,\n    value: function value(job, stat) {\n      this.statCache.set(job.absolute, stat);\n      job.stat = stat; // now we have the stat, we can filter it.\n\n      if (!this.filter(job.path, stat)) job.ignore = true;\n      this[PROCESS]();\n    }\n  }, {\n    key: READDIR,\n    value: function value(job) {\n      var _this4 = this;\n\n      job.pending = true;\n      this[JOBS] += 1;\n      fs.readdir(job.absolute, function (er, entries) {\n        job.pending = false;\n        _this4[JOBS] -= 1;\n        if (er) return _this4.emit('error', er);\n\n        _this4[ONREADDIR](job, entries);\n      });\n    }\n  }, {\n    key: ONREADDIR,\n    value: function value(job, entries) {\n      this.readdirCache.set(job.absolute, entries);\n      job.readdir = entries;\n      this[PROCESS]();\n    }\n  }, {\n    key: PROCESS,\n    value: function value() {\n      if (this[PROCESSING]) return;\n      this[PROCESSING] = true;\n\n      for (var w = this[QUEUE].head; w !== null && this[JOBS] < this.jobs; w = w.next) {\n        this[PROCESSJOB](w.value);\n\n        if (w.value.ignore) {\n          var p = w.next;\n          this[QUEUE].removeNode(w);\n          w.next = p;\n        }\n      }\n\n      this[PROCESSING] = false;\n\n      if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {\n        if (this.zip) this.zip.end(EOF);else {\n          _get(_getPrototypeOf(Pack.prototype), \"write\", this).call(this, EOF);\n\n          _get(_getPrototypeOf(Pack.prototype), \"end\", this).call(this);\n        }\n      }\n    }\n  }, {\n    key: CURRENT,\n    get: function get() {\n      return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value;\n    }\n  }, {\n    key: JOBDONE,\n    value: function value(job) {\n      this[QUEUE].shift();\n      this[JOBS] -= 1;\n      this[PROCESS]();\n    }\n  }, {\n    key: PROCESSJOB,\n    value: function value(job) {\n      if (job.pending) return;\n\n      if (job.entry) {\n        if (job === this[CURRENT] && !job.piped) this[PIPE](job);\n        return;\n      }\n\n      if (!job.stat) {\n        if (this.statCache.has(job.absolute)) this[ONSTAT](job, this.statCache.get(job.absolute));else this[STAT](job);\n      }\n\n      if (!job.stat) return; // filtered out!\n\n      if (job.ignore) return;\n\n      if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {\n        if (this.readdirCache.has(job.absolute)) this[ONREADDIR](job, this.readdirCache.get(job.absolute));else this[READDIR](job);\n        if (!job.readdir) return;\n      } // we know it doesn't have an entry, because that got checked above\n\n\n      job.entry = this[ENTRY](job);\n\n      if (!job.entry) {\n        job.ignore = true;\n        return;\n      }\n\n      if (job === this[CURRENT] && !job.piped) this[PIPE](job);\n    }\n  }, {\n    key: ENTRYOPT,\n    value: function value(job) {\n      var _this5 = this;\n\n      return {\n        onwarn: function onwarn(code, msg, data) {\n          return _this5.warn(code, msg, data);\n        },\n        noPax: this.noPax,\n        cwd: this.cwd,\n        absolute: job.absolute,\n        preservePaths: this.preservePaths,\n        maxReadSize: this.maxReadSize,\n        strict: this.strict,\n        portable: this.portable,\n        linkCache: this.linkCache,\n        statCache: this.statCache,\n        noMtime: this.noMtime,\n        mtime: this.mtime\n      };\n    }\n  }, {\n    key: ENTRY,\n    value: function value(job) {\n      var _this6 = this;\n\n      this[JOBS] += 1;\n\n      try {\n        return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job)).on('end', function () {\n          return _this6[JOBDONE](job);\n        }).on('error', function (er) {\n          return _this6.emit('error', er);\n        });\n      } catch (er) {\n        this.emit('error', er);\n      }\n    }\n  }, {\n    key: ONDRAIN,\n    value: function value() {\n      if (this[CURRENT] && this[CURRENT].entry) this[CURRENT].entry.resume();\n    } // like .pipe() but using super, because our write() is special\n\n  }, {\n    key: PIPE,\n    value: function value(job) {\n      var _this7 = this;\n\n      job.piped = true;\n\n      if (job.readdir) {\n        job.readdir.forEach(function (entry) {\n          var p = _this7.prefix ? job.path.slice(_this7.prefix.length + 1) || './' : job.path;\n          var base = p === './' ? '' : p.replace(/\\/*$/, '/');\n\n          _this7[ADDFSENTRY](base + entry);\n        });\n      }\n\n      var source = job.entry;\n      var zip = this.zip;\n\n      if (zip) {\n        source.on('data', function (chunk) {\n          if (!zip.write(chunk)) source.pause();\n        });\n      } else {\n        source.on('data', function (chunk) {\n          if (!_get(_getPrototypeOf(Pack.prototype), \"write\", _this7).call(_this7, chunk)) source.pause();\n        });\n      }\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      if (this.zip) this.zip.pause();\n      return _get(_getPrototypeOf(Pack.prototype), \"pause\", this).call(this);\n    }\n  }]);\n\n  return Pack;\n}(MiniPass));\n\nvar PackSync = /*#__PURE__*/function (_Pack) {\n  _inherits(PackSync, _Pack);\n\n  var _super2 = _createSuper(PackSync);\n\n  function PackSync(opt) {\n    var _this8;\n\n    _classCallCheck(this, PackSync);\n\n    _this8 = _super2.call(this, opt);\n    _this8[WRITEENTRYCLASS] = WriteEntrySync;\n    return _this8;\n  } // pause/resume are no-ops in sync streams.\n\n\n  _createClass(PackSync, [{\n    key: \"pause\",\n    value: function pause() {}\n  }, {\n    key: \"resume\",\n    value: function resume() {}\n  }, {\n    key: STAT,\n    value: function value(job) {\n      var stat = this.follow ? 'statSync' : 'lstatSync';\n      this[ONSTAT](job, fs[stat](job.absolute));\n    }\n  }, {\n    key: READDIR,\n    value: function value(job, stat) {\n      this[ONREADDIR](job, fs.readdirSync(job.absolute));\n    } // gotta get it all in this tick\n\n  }, {\n    key: PIPE,\n    value: function value(job) {\n      var _this9 = this;\n\n      var source = job.entry;\n      var zip = this.zip;\n\n      if (job.readdir) {\n        job.readdir.forEach(function (entry) {\n          var p = _this9.prefix ? job.path.slice(_this9.prefix.length + 1) || './' : job.path;\n          var base = p === './' ? '' : p.replace(/\\/*$/, '/');\n\n          _this9[ADDFSENTRY](base + entry);\n        });\n      }\n\n      if (zip) {\n        source.on('data', function (chunk) {\n          zip.write(chunk);\n        });\n      } else {\n        source.on('data', function (chunk) {\n          _get(_getPrototypeOf(PackSync.prototype), WRITE, _this9).call(_this9, chunk);\n        });\n      }\n    }\n  }]);\n\n  return PackSync;\n}(Pack);\n\nPack.Sync = PackSync;\nmodule.exports = Pack;","map":{"version":3,"sources":["/Users/austenhughes/The-Baffoonery/node_modules/tar/lib/pack.js"],"names":["PackJob","path","absolute","entry","stat","readdir","pending","ignore","piped","MiniPass","require","zlib","ReadEntry","WriteEntry","WriteEntrySync","Sync","WriteEntryTar","Tar","Yallist","EOF","Buffer","alloc","ONSTAT","Symbol","ENDED","QUEUE","CURRENT","PROCESS","PROCESSING","PROCESSJOB","JOBS","JOBDONE","ADDFSENTRY","ADDTARENTRY","STAT","READDIR","ONREADDIR","PIPE","ENTRY","ENTRYOPT","WRITEENTRYCLASS","WRITE","ONDRAIN","fs","warner","Pack","opt","Object","create","file","cwd","process","maxReadSize","preservePaths","strict","noPax","prefix","replace","linkCache","Map","statCache","readdirCache","onwarn","on","portable","zip","gzip","Gzip","chunk","_","resume","noDirRecurse","follow","noMtime","mtime","filter","jobs","write","Error","flowing","p","resolve","job","push","er","emit","set","entries","w","head","next","value","removeNode","length","end","shift","has","get","isDirectory","code","msg","data","warn","forEach","slice","base","source","pause","PackSync","readdirSync","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\n// A readable tar stream creator\n// Technically, this is a transform stream that you write paths into,\n// and tar format comes out of.\n// The `add()` method is like `write()` but returns this,\n// and end() return `this` as well, so you can\n// do `new Pack(opt).add('files').add('dir').end().pipe(output)\n// You could also do something like:\n// streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))\n\nclass PackJob {\n  constructor (path, absolute) {\n    this.path = path || './'\n    this.absolute = absolute\n    this.entry = null\n    this.stat = null\n    this.readdir = null\n    this.pending = false\n    this.ignore = false\n    this.piped = false\n  }\n}\n\nconst MiniPass = require('minipass')\nconst zlib = require('minizlib')\nconst ReadEntry = require('./read-entry.js')\nconst WriteEntry = require('./write-entry.js')\nconst WriteEntrySync = WriteEntry.Sync\nconst WriteEntryTar = WriteEntry.Tar\nconst Yallist = require('yallist')\nconst EOF = Buffer.alloc(1024)\nconst ONSTAT = Symbol('onStat')\nconst ENDED = Symbol('ended')\nconst QUEUE = Symbol('queue')\nconst CURRENT = Symbol('current')\nconst PROCESS = Symbol('process')\nconst PROCESSING = Symbol('processing')\nconst PROCESSJOB = Symbol('processJob')\nconst JOBS = Symbol('jobs')\nconst JOBDONE = Symbol('jobDone')\nconst ADDFSENTRY = Symbol('addFSEntry')\nconst ADDTARENTRY = Symbol('addTarEntry')\nconst STAT = Symbol('stat')\nconst READDIR = Symbol('readdir')\nconst ONREADDIR = Symbol('onreaddir')\nconst PIPE = Symbol('pipe')\nconst ENTRY = Symbol('entry')\nconst ENTRYOPT = Symbol('entryOpt')\nconst WRITEENTRYCLASS = Symbol('writeEntryClass')\nconst WRITE = Symbol('write')\nconst ONDRAIN = Symbol('ondrain')\n\nconst fs = require('fs')\nconst path = require('path')\nconst warner = require('./warn-mixin.js')\n\nconst Pack = warner(class Pack extends MiniPass {\n  constructor (opt) {\n    super(opt)\n    opt = opt || Object.create(null)\n    this.opt = opt\n    this.file = opt.file || ''\n    this.cwd = opt.cwd || process.cwd()\n    this.maxReadSize = opt.maxReadSize\n    this.preservePaths = !!opt.preservePaths\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.prefix = (opt.prefix || '').replace(/(\\\\|\\/)+$/, '')\n    this.linkCache = opt.linkCache || new Map()\n    this.statCache = opt.statCache || new Map()\n    this.readdirCache = opt.readdirCache || new Map()\n\n    this[WRITEENTRYCLASS] = WriteEntry\n    if (typeof opt.onwarn === 'function')\n      this.on('warn', opt.onwarn)\n\n    this.portable = !!opt.portable\n    this.zip = null\n    if (opt.gzip) {\n      if (typeof opt.gzip !== 'object')\n        opt.gzip = {}\n      if (this.portable)\n        opt.gzip.portable = true\n      this.zip = new zlib.Gzip(opt.gzip)\n      this.zip.on('data', chunk => super.write(chunk))\n      this.zip.on('end', _ => super.end())\n      this.zip.on('drain', _ => this[ONDRAIN]())\n      this.on('resume', _ => this.zip.resume())\n    } else\n      this.on('drain', this[ONDRAIN])\n\n    this.noDirRecurse = !!opt.noDirRecurse\n    this.follow = !!opt.follow\n    this.noMtime = !!opt.noMtime\n    this.mtime = opt.mtime || null\n\n    this.filter = typeof opt.filter === 'function' ? opt.filter : _ => true\n\n    this[QUEUE] = new Yallist()\n    this[JOBS] = 0\n    this.jobs = +opt.jobs || 4\n    this[PROCESSING] = false\n    this[ENDED] = false\n  }\n\n  [WRITE] (chunk) {\n    return super.write(chunk)\n  }\n\n  add (path) {\n    this.write(path)\n    return this\n  }\n\n  end (path) {\n    if (path)\n      this.write(path)\n    this[ENDED] = true\n    this[PROCESS]()\n    return this\n  }\n\n  write (path) {\n    if (this[ENDED])\n      throw new Error('write after end')\n\n    if (path instanceof ReadEntry)\n      this[ADDTARENTRY](path)\n    else\n      this[ADDFSENTRY](path)\n    return this.flowing\n  }\n\n  [ADDTARENTRY] (p) {\n    const absolute = path.resolve(this.cwd, p.path)\n    if (this.prefix)\n      p.path = this.prefix + '/' + p.path.replace(/^\\.(\\/+|$)/, '')\n\n    // in this case, we don't have to wait for the stat\n    if (!this.filter(p.path, p))\n      p.resume()\n    else {\n      const job = new PackJob(p.path, absolute, false)\n      job.entry = new WriteEntryTar(p, this[ENTRYOPT](job))\n      job.entry.on('end', _ => this[JOBDONE](job))\n      this[JOBS] += 1\n      this[QUEUE].push(job)\n    }\n\n    this[PROCESS]()\n  }\n\n  [ADDFSENTRY] (p) {\n    const absolute = path.resolve(this.cwd, p)\n    if (this.prefix)\n      p = this.prefix + '/' + p.replace(/^\\.(\\/+|$)/, '')\n\n    this[QUEUE].push(new PackJob(p, absolute))\n    this[PROCESS]()\n  }\n\n  [STAT] (job) {\n    job.pending = true\n    this[JOBS] += 1\n    const stat = this.follow ? 'stat' : 'lstat'\n    fs[stat](job.absolute, (er, stat) => {\n      job.pending = false\n      this[JOBS] -= 1\n      if (er)\n        this.emit('error', er)\n      else\n        this[ONSTAT](job, stat)\n    })\n  }\n\n  [ONSTAT] (job, stat) {\n    this.statCache.set(job.absolute, stat)\n    job.stat = stat\n\n    // now we have the stat, we can filter it.\n    if (!this.filter(job.path, stat))\n      job.ignore = true\n\n    this[PROCESS]()\n  }\n\n  [READDIR] (job) {\n    job.pending = true\n    this[JOBS] += 1\n    fs.readdir(job.absolute, (er, entries) => {\n      job.pending = false\n      this[JOBS] -= 1\n      if (er)\n        return this.emit('error', er)\n      this[ONREADDIR](job, entries)\n    })\n  }\n\n  [ONREADDIR] (job, entries) {\n    this.readdirCache.set(job.absolute, entries)\n    job.readdir = entries\n    this[PROCESS]()\n  }\n\n  [PROCESS] () {\n    if (this[PROCESSING])\n      return\n\n    this[PROCESSING] = true\n    for (let w = this[QUEUE].head;\n      w !== null && this[JOBS] < this.jobs;\n      w = w.next) {\n      this[PROCESSJOB](w.value)\n      if (w.value.ignore) {\n        const p = w.next\n        this[QUEUE].removeNode(w)\n        w.next = p\n      }\n    }\n\n    this[PROCESSING] = false\n\n    if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {\n      if (this.zip)\n        this.zip.end(EOF)\n      else {\n        super.write(EOF)\n        super.end()\n      }\n    }\n  }\n\n  get [CURRENT] () {\n    return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value\n  }\n\n  [JOBDONE] (job) {\n    this[QUEUE].shift()\n    this[JOBS] -= 1\n    this[PROCESS]()\n  }\n\n  [PROCESSJOB] (job) {\n    if (job.pending)\n      return\n\n    if (job.entry) {\n      if (job === this[CURRENT] && !job.piped)\n        this[PIPE](job)\n      return\n    }\n\n    if (!job.stat) {\n      if (this.statCache.has(job.absolute))\n        this[ONSTAT](job, this.statCache.get(job.absolute))\n      else\n        this[STAT](job)\n    }\n    if (!job.stat)\n      return\n\n    // filtered out!\n    if (job.ignore)\n      return\n\n    if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {\n      if (this.readdirCache.has(job.absolute))\n        this[ONREADDIR](job, this.readdirCache.get(job.absolute))\n      else\n        this[READDIR](job)\n      if (!job.readdir)\n        return\n    }\n\n    // we know it doesn't have an entry, because that got checked above\n    job.entry = this[ENTRY](job)\n    if (!job.entry) {\n      job.ignore = true\n      return\n    }\n\n    if (job === this[CURRENT] && !job.piped)\n      this[PIPE](job)\n  }\n\n  [ENTRYOPT] (job) {\n    return {\n      onwarn: (code, msg, data) => this.warn(code, msg, data),\n      noPax: this.noPax,\n      cwd: this.cwd,\n      absolute: job.absolute,\n      preservePaths: this.preservePaths,\n      maxReadSize: this.maxReadSize,\n      strict: this.strict,\n      portable: this.portable,\n      linkCache: this.linkCache,\n      statCache: this.statCache,\n      noMtime: this.noMtime,\n      mtime: this.mtime,\n    }\n  }\n\n  [ENTRY] (job) {\n    this[JOBS] += 1\n    try {\n      return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job))\n        .on('end', () => this[JOBDONE](job))\n        .on('error', er => this.emit('error', er))\n    } catch (er) {\n      this.emit('error', er)\n    }\n  }\n\n  [ONDRAIN] () {\n    if (this[CURRENT] && this[CURRENT].entry)\n      this[CURRENT].entry.resume()\n  }\n\n  // like .pipe() but using super, because our write() is special\n  [PIPE] (job) {\n    job.piped = true\n\n    if (job.readdir) {\n      job.readdir.forEach(entry => {\n        const p = this.prefix ?\n          job.path.slice(this.prefix.length + 1) || './'\n          : job.path\n\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/')\n        this[ADDFSENTRY](base + entry)\n      })\n    }\n\n    const source = job.entry\n    const zip = this.zip\n\n    if (zip) {\n      source.on('data', chunk => {\n        if (!zip.write(chunk))\n          source.pause()\n      })\n    } else {\n      source.on('data', chunk => {\n        if (!super.write(chunk))\n          source.pause()\n      })\n    }\n  }\n\n  pause () {\n    if (this.zip)\n      this.zip.pause()\n    return super.pause()\n  }\n})\n\nclass PackSync extends Pack {\n  constructor (opt) {\n    super(opt)\n    this[WRITEENTRYCLASS] = WriteEntrySync\n  }\n\n  // pause/resume are no-ops in sync streams.\n  pause () {}\n  resume () {}\n\n  [STAT] (job) {\n    const stat = this.follow ? 'statSync' : 'lstatSync'\n    this[ONSTAT](job, fs[stat](job.absolute))\n  }\n\n  [READDIR] (job, stat) {\n    this[ONREADDIR](job, fs.readdirSync(job.absolute))\n  }\n\n  // gotta get it all in this tick\n  [PIPE] (job) {\n    const source = job.entry\n    const zip = this.zip\n\n    if (job.readdir) {\n      job.readdir.forEach(entry => {\n        const p = this.prefix ?\n          job.path.slice(this.prefix.length + 1) || './'\n          : job.path\n\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/')\n        this[ADDFSENTRY](base + entry)\n      })\n    }\n\n    if (zip) {\n      source.on('data', chunk => {\n        zip.write(chunk)\n      })\n    } else {\n      source.on('data', chunk => {\n        super[WRITE](chunk)\n      })\n    }\n  }\n}\n\nPack.Sync = PackSync\n\nmodule.exports = Pack\n"]},"metadata":{},"sourceType":"script"}