{"ast":null,"code":"'use strict';\n\nmodule.exports = exports = testpackage;\nexports.usage = 'Tests that the staged package is valid';\n\nvar fs = require('fs');\n\nvar path = require('path');\n\nvar log = require('npmlog');\n\nvar existsAsync = fs.exists || path.exists;\n\nvar versioning = require('./util/versioning.js');\n\nvar napi = require('./util/napi.js');\n\nvar testbinary = require('./testbinary.js');\n\nvar tar = require('tar');\n\nvar makeDir = require('make-dir');\n\nfunction testpackage(gyp, argv, callback) {\n  var package_json = gyp.package_json;\n  var napi_build_version = napi.get_napi_build_version_from_command_args(argv);\n  var opts = versioning.evaluate(package_json, gyp.opts, napi_build_version);\n  var tarball = opts.staged_tarball;\n  existsAsync(tarball, function (found) {\n    if (!found) {\n      return callback(new Error('Cannot test package because ' + tarball + ' missing: run `node-pre-gyp package` first'));\n    }\n\n    var to = opts.module_path;\n\n    function filter_func(entry) {\n      log.info('install', 'unpacking [' + entry.path + ']');\n    }\n\n    makeDir(to).then(function () {\n      tar.extract({\n        file: tarball,\n        cwd: to,\n        strip: 1,\n        onentry: filter_func\n      }).then(after_extract, callback);\n    }).catch(function (err) {\n      return callback(err);\n    });\n\n    function after_extract() {\n      testbinary(gyp, argv, function (err) {\n        if (err) {\n          return callback(err);\n        } else {\n          console.log('[' + package_json.name + '] Package appears valid');\n          return callback();\n        }\n      });\n    }\n  });\n}","map":{"version":3,"sources":["/Users/austenhughes/The-Baffoonery/node_modules/@mapbox/node-pre-gyp/lib/testpackage.js"],"names":["module","exports","testpackage","usage","fs","require","path","log","existsAsync","exists","versioning","napi","testbinary","tar","makeDir","gyp","argv","callback","package_json","napi_build_version","get_napi_build_version_from_command_args","opts","evaluate","tarball","staged_tarball","found","Error","to","module_path","filter_func","entry","info","then","extract","file","cwd","strip","onentry","after_extract","catch","err","console","name"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,OAAP,GAAiBA,OAAO,GAAGC,WAA3B;AAEAD,OAAO,CAACE,KAAR,GAAgB,wCAAhB;;AAEA,IAAMC,EAAE,GAAGC,OAAO,CAAC,IAAD,CAAlB;;AACA,IAAMC,IAAI,GAAGD,OAAO,CAAC,MAAD,CAApB;;AACA,IAAME,GAAG,GAAGF,OAAO,CAAC,QAAD,CAAnB;;AACA,IAAMG,WAAW,GAAGJ,EAAE,CAACK,MAAH,IAAaH,IAAI,CAACG,MAAtC;;AACA,IAAMC,UAAU,GAAGL,OAAO,CAAC,sBAAD,CAA1B;;AACA,IAAMM,IAAI,GAAGN,OAAO,CAAC,gBAAD,CAApB;;AACA,IAAMO,UAAU,GAAGP,OAAO,CAAC,iBAAD,CAA1B;;AACA,IAAMQ,GAAG,GAAGR,OAAO,CAAC,KAAD,CAAnB;;AACA,IAAMS,OAAO,GAAGT,OAAO,CAAC,UAAD,CAAvB;;AAEA,SAASH,WAAT,CAAqBa,GAArB,EAA0BC,IAA1B,EAAgCC,QAAhC,EAA0C;AACxC,MAAMC,YAAY,GAAGH,GAAG,CAACG,YAAzB;AACA,MAAMC,kBAAkB,GAAGR,IAAI,CAACS,wCAAL,CAA8CJ,IAA9C,CAA3B;AACA,MAAMK,IAAI,GAAGX,UAAU,CAACY,QAAX,CAAoBJ,YAApB,EAAkCH,GAAG,CAACM,IAAtC,EAA4CF,kBAA5C,CAAb;AACA,MAAMI,OAAO,GAAGF,IAAI,CAACG,cAArB;AACAhB,EAAAA,WAAW,CAACe,OAAD,EAAU,UAACE,KAAD,EAAW;AAC9B,QAAI,CAACA,KAAL,EAAY;AACV,aAAOR,QAAQ,CAAC,IAAIS,KAAJ,CAAU,iCAAiCH,OAAjC,GAA2C,4CAArD,CAAD,CAAf;AACD;;AACD,QAAMI,EAAE,GAAGN,IAAI,CAACO,WAAhB;;AACA,aAASC,WAAT,CAAqBC,KAArB,EAA4B;AAC1BvB,MAAAA,GAAG,CAACwB,IAAJ,CAAS,SAAT,EAAoB,gBAAgBD,KAAK,CAACxB,IAAtB,GAA6B,GAAjD;AACD;;AAEDQ,IAAAA,OAAO,CAACa,EAAD,CAAP,CAAYK,IAAZ,CAAiB,YAAM;AACrBnB,MAAAA,GAAG,CAACoB,OAAJ,CAAY;AACVC,QAAAA,IAAI,EAAEX,OADI;AAEVY,QAAAA,GAAG,EAAER,EAFK;AAGVS,QAAAA,KAAK,EAAE,CAHG;AAIVC,QAAAA,OAAO,EAAER;AAJC,OAAZ,EAKGG,IALH,CAKQM,aALR,EAKuBrB,QALvB;AAMD,KAPD,EAOGsB,KAPH,CAOS,UAACC,GAAD,EAAS;AAChB,aAAOvB,QAAQ,CAACuB,GAAD,CAAf;AACD,KATD;;AAWA,aAASF,aAAT,GAAyB;AACvB1B,MAAAA,UAAU,CAACG,GAAD,EAAMC,IAAN,EAAY,UAACwB,GAAD,EAAS;AAC7B,YAAIA,GAAJ,EAAS;AACP,iBAAOvB,QAAQ,CAACuB,GAAD,CAAf;AACD,SAFD,MAEO;AACLC,UAAAA,OAAO,CAAClC,GAAR,CAAY,MAAMW,YAAY,CAACwB,IAAnB,GAA0B,yBAAtC;AACA,iBAAOzB,QAAQ,EAAf;AACD;AACF,OAPS,CAAV;AAQD;AACF,GA9BU,CAAX;AA+BD","sourcesContent":["'use strict';\n\nmodule.exports = exports = testpackage;\n\nexports.usage = 'Tests that the staged package is valid';\n\nconst fs = require('fs');\nconst path = require('path');\nconst log = require('npmlog');\nconst existsAsync = fs.exists || path.exists;\nconst versioning = require('./util/versioning.js');\nconst napi = require('./util/napi.js');\nconst testbinary = require('./testbinary.js');\nconst tar = require('tar');\nconst makeDir = require('make-dir');\n\nfunction testpackage(gyp, argv, callback) {\n  const package_json = gyp.package_json;\n  const napi_build_version = napi.get_napi_build_version_from_command_args(argv);\n  const opts = versioning.evaluate(package_json, gyp.opts, napi_build_version);\n  const tarball = opts.staged_tarball;\n  existsAsync(tarball, (found) => {\n    if (!found) {\n      return callback(new Error('Cannot test package because ' + tarball + ' missing: run `node-pre-gyp package` first'));\n    }\n    const to = opts.module_path;\n    function filter_func(entry) {\n      log.info('install', 'unpacking [' + entry.path + ']');\n    }\n\n    makeDir(to).then(() => {\n      tar.extract({\n        file: tarball,\n        cwd: to,\n        strip: 1,\n        onentry: filter_func\n      }).then(after_extract, callback);\n    }).catch((err) => {\n      return callback(err);\n    });\n\n    function after_extract() {\n      testbinary(gyp, argv, (err) => {\n        if (err) {\n          return callback(err);\n        } else {\n          console.log('[' + package_json.name + '] Package appears valid');\n          return callback();\n        }\n      });\n    }\n  });\n}\n"]},"metadata":{},"sourceType":"script"}