{"ast":null,"code":"'use strict';\n\nvar _get = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _classCallCheck = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar MiniPass = require('minipass');\n\nvar Pax = require('./pax.js');\n\nvar Header = require('./header.js');\n\nvar fs = require('fs');\n\nvar path = require('path');\n\nvar maxReadSize = 16 * 1024 * 1024;\nvar PROCESS = Symbol('process');\nvar FILE = Symbol('file');\nvar DIRECTORY = Symbol('directory');\nvar SYMLINK = Symbol('symlink');\nvar HARDLINK = Symbol('hardlink');\nvar HEADER = Symbol('header');\nvar READ = Symbol('read');\nvar LSTAT = Symbol('lstat');\nvar ONLSTAT = Symbol('onlstat');\nvar ONREAD = Symbol('onread');\nvar ONREADLINK = Symbol('onreadlink');\nvar OPENFILE = Symbol('openfile');\nvar ONOPENFILE = Symbol('onopenfile');\nvar CLOSE = Symbol('close');\nvar MODE = Symbol('mode');\n\nvar warner = require('./warn-mixin.js');\n\nvar winchars = require('./winchars.js');\n\nvar modeFix = require('./mode-fix.js');\n\nvar WriteEntry = warner( /*#__PURE__*/function (_MiniPass) {\n  _inherits(WriteEntry, _MiniPass);\n\n  var _super = _createSuper(WriteEntry);\n\n  function WriteEntry(p, opt) {\n    var _this;\n\n    _classCallCheck(this, WriteEntry);\n\n    opt = opt || {};\n    _this = _super.call(this, opt);\n    if (typeof p !== 'string') throw new TypeError('path is required');\n    _this.path = p; // suppress atime, ctime, uid, gid, uname, gname\n\n    _this.portable = !!opt.portable; // until node has builtin pwnam functions, this'll have to do\n\n    _this.myuid = process.getuid && process.getuid();\n    _this.myuser = process.env.USER || '';\n    _this.maxReadSize = opt.maxReadSize || maxReadSize;\n    _this.linkCache = opt.linkCache || new Map();\n    _this.statCache = opt.statCache || new Map();\n    _this.preservePaths = !!opt.preservePaths;\n    _this.cwd = opt.cwd || process.cwd();\n    _this.strict = !!opt.strict;\n    _this.noPax = !!opt.noPax;\n    _this.noMtime = !!opt.noMtime;\n    _this.mtime = opt.mtime || null;\n    if (typeof opt.onwarn === 'function') _this.on('warn', opt.onwarn);\n    var pathWarn = false;\n\n    if (!_this.preservePaths && path.win32.isAbsolute(p)) {\n      // absolutes on posix are also absolutes on win32\n      // so we only need to test this one to get both\n      var parsed = path.win32.parse(p);\n      _this.path = p.substr(parsed.root.length);\n      pathWarn = parsed.root;\n    }\n\n    _this.win32 = !!opt.win32 || process.platform === 'win32';\n\n    if (_this.win32) {\n      _this.path = winchars.decode(_this.path.replace(/\\\\/g, '/'));\n      p = p.replace(/\\\\/g, '/');\n    }\n\n    _this.absolute = opt.absolute || path.resolve(_this.cwd, p);\n    if (_this.path === '') _this.path = './';\n\n    if (pathWarn) {\n      _this.warn('TAR_ENTRY_INFO', \"stripping \".concat(pathWarn, \" from absolute path\"), {\n        entry: _assertThisInitialized(_this),\n        path: pathWarn + _this.path\n      });\n    }\n\n    if (_this.statCache.has(_this.absolute)) _this[ONLSTAT](_this.statCache.get(_this.absolute));else _this[LSTAT]();\n    return _this;\n  }\n\n  _createClass(WriteEntry, [{\n    key: LSTAT,\n    value: function value() {\n      var _this2 = this;\n\n      fs.lstat(this.absolute, function (er, stat) {\n        if (er) return _this2.emit('error', er);\n\n        _this2[ONLSTAT](stat);\n      });\n    }\n  }, {\n    key: ONLSTAT,\n    value: function value(stat) {\n      this.statCache.set(this.absolute, stat);\n      this.stat = stat;\n      if (!stat.isFile()) stat.size = 0;\n      this.type = getType(stat);\n      this.emit('stat', stat);\n      this[PROCESS]();\n    }\n  }, {\n    key: PROCESS,\n    value: function value() {\n      switch (this.type) {\n        case 'File':\n          return this[FILE]();\n\n        case 'Directory':\n          return this[DIRECTORY]();\n\n        case 'SymbolicLink':\n          return this[SYMLINK]();\n        // unsupported types are ignored.\n\n        default:\n          return this.end();\n      }\n    }\n  }, {\n    key: MODE,\n    value: function value(mode) {\n      return modeFix(mode, this.type === 'Directory', this.portable);\n    }\n  }, {\n    key: HEADER,\n    value: function value() {\n      if (this.type === 'Directory' && this.portable) this.noMtime = true;\n      this.header = new Header({\n        path: this.path,\n        linkpath: this.linkpath,\n        // only the permissions and setuid/setgid/sticky bitflags\n        // not the higher-order bits that specify file type\n        mode: this[MODE](this.stat.mode),\n        uid: this.portable ? null : this.stat.uid,\n        gid: this.portable ? null : this.stat.gid,\n        size: this.stat.size,\n        mtime: this.noMtime ? null : this.mtime || this.stat.mtime,\n        type: this.type,\n        uname: this.portable ? null : this.stat.uid === this.myuid ? this.myuser : '',\n        atime: this.portable ? null : this.stat.atime,\n        ctime: this.portable ? null : this.stat.ctime\n      });\n\n      if (this.header.encode() && !this.noPax) {\n        this.write(new Pax({\n          atime: this.portable ? null : this.header.atime,\n          ctime: this.portable ? null : this.header.ctime,\n          gid: this.portable ? null : this.header.gid,\n          mtime: this.noMtime ? null : this.mtime || this.header.mtime,\n          path: this.path,\n          linkpath: this.linkpath,\n          size: this.header.size,\n          uid: this.portable ? null : this.header.uid,\n          uname: this.portable ? null : this.header.uname,\n          dev: this.portable ? null : this.stat.dev,\n          ino: this.portable ? null : this.stat.ino,\n          nlink: this.portable ? null : this.stat.nlink\n        }).encode());\n      }\n\n      this.write(this.header.block);\n    }\n  }, {\n    key: DIRECTORY,\n    value: function value() {\n      if (this.path.substr(-1) !== '/') this.path += '/';\n      this.stat.size = 0;\n      this[HEADER]();\n      this.end();\n    }\n  }, {\n    key: SYMLINK,\n    value: function value() {\n      var _this3 = this;\n\n      fs.readlink(this.absolute, function (er, linkpath) {\n        if (er) return _this3.emit('error', er);\n\n        _this3[ONREADLINK](linkpath);\n      });\n    }\n  }, {\n    key: ONREADLINK,\n    value: function value(linkpath) {\n      this.linkpath = linkpath.replace(/\\\\/g, '/');\n      this[HEADER]();\n      this.end();\n    }\n  }, {\n    key: HARDLINK,\n    value: function value(linkpath) {\n      this.type = 'Link';\n      this.linkpath = path.relative(this.cwd, linkpath).replace(/\\\\/g, '/');\n      this.stat.size = 0;\n      this[HEADER]();\n      this.end();\n    }\n  }, {\n    key: FILE,\n    value: function value() {\n      if (this.stat.nlink > 1) {\n        var linkKey = this.stat.dev + ':' + this.stat.ino;\n\n        if (this.linkCache.has(linkKey)) {\n          var linkpath = this.linkCache.get(linkKey);\n          if (linkpath.indexOf(this.cwd) === 0) return this[HARDLINK](linkpath);\n        }\n\n        this.linkCache.set(linkKey, this.absolute);\n      }\n\n      this[HEADER]();\n      if (this.stat.size === 0) return this.end();\n      this[OPENFILE]();\n    }\n  }, {\n    key: OPENFILE,\n    value: function value() {\n      var _this4 = this;\n\n      fs.open(this.absolute, 'r', function (er, fd) {\n        if (er) return _this4.emit('error', er);\n\n        _this4[ONOPENFILE](fd);\n      });\n    }\n  }, {\n    key: ONOPENFILE,\n    value: function value(fd) {\n      var blockLen = 512 * Math.ceil(this.stat.size / 512);\n      var bufLen = Math.min(blockLen, this.maxReadSize);\n      var buf = Buffer.allocUnsafe(bufLen);\n      this[READ](fd, buf, 0, buf.length, 0, this.stat.size, blockLen);\n    }\n  }, {\n    key: READ,\n    value: function value(fd, buf, offset, length, pos, remain, blockRemain) {\n      var _this5 = this;\n\n      fs.read(fd, buf, offset, length, pos, function (er, bytesRead) {\n        if (er) {\n          // ignoring the error from close(2) is a bad practice, but at\n          // this point we already have an error, don't need another one\n          return _this5[CLOSE](fd, function () {\n            return _this5.emit('error', er);\n          });\n        }\n\n        _this5[ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead);\n      });\n    }\n  }, {\n    key: CLOSE,\n    value: function value(fd, cb) {\n      fs.close(fd, cb);\n    }\n  }, {\n    key: ONREAD,\n    value: function value(fd, buf, offset, length, pos, remain, blockRemain, bytesRead) {\n      var _this6 = this;\n\n      if (bytesRead <= 0 && remain > 0) {\n        var er = new Error('encountered unexpected EOF');\n        er.path = this.absolute;\n        er.syscall = 'read';\n        er.code = 'EOF';\n        return this[CLOSE](fd, function () {\n          return _this6.emit('error', er);\n        });\n      }\n\n      if (bytesRead > remain) {\n        var _er = new Error('did not encounter expected EOF');\n\n        _er.path = this.absolute;\n        _er.syscall = 'read';\n        _er.code = 'EOF';\n        return this[CLOSE](fd, function () {\n          return _this6.emit('error', _er);\n        });\n      } // null out the rest of the buffer, if we could fit the block padding\n\n\n      if (bytesRead === remain) {\n        for (var i = bytesRead; i < length && bytesRead < blockRemain; i++) {\n          buf[i + offset] = 0;\n          bytesRead++;\n          remain++;\n        }\n      }\n\n      var writeBuf = offset === 0 && bytesRead === buf.length ? buf : buf.slice(offset, offset + bytesRead);\n      remain -= bytesRead;\n      blockRemain -= bytesRead;\n      pos += bytesRead;\n      offset += bytesRead;\n      this.write(writeBuf);\n\n      if (!remain) {\n        if (blockRemain) this.write(Buffer.alloc(blockRemain));\n        return this[CLOSE](fd, function (er) {\n          return er ? _this6.emit('error', er) : _this6.end();\n        });\n      }\n\n      if (offset >= length) {\n        buf = Buffer.allocUnsafe(length);\n        offset = 0;\n      }\n\n      length = buf.length - offset;\n      this[READ](fd, buf, offset, length, pos, remain, blockRemain);\n    }\n  }]);\n\n  return WriteEntry;\n}(MiniPass));\n\nvar WriteEntrySync = /*#__PURE__*/function (_WriteEntry) {\n  _inherits(WriteEntrySync, _WriteEntry);\n\n  var _super2 = _createSuper(WriteEntrySync);\n\n  function WriteEntrySync() {\n    _classCallCheck(this, WriteEntrySync);\n\n    return _super2.apply(this, arguments);\n  }\n\n  _createClass(WriteEntrySync, [{\n    key: LSTAT,\n    value: function value() {\n      this[ONLSTAT](fs.lstatSync(this.absolute));\n    }\n  }, {\n    key: SYMLINK,\n    value: function value() {\n      this[ONREADLINK](fs.readlinkSync(this.absolute));\n    }\n  }, {\n    key: OPENFILE,\n    value: function value() {\n      this[ONOPENFILE](fs.openSync(this.absolute, 'r'));\n    }\n  }, {\n    key: READ,\n    value: function value(fd, buf, offset, length, pos, remain, blockRemain) {\n      var threw = true;\n\n      try {\n        var bytesRead = fs.readSync(fd, buf, offset, length, pos);\n        this[ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead);\n        threw = false;\n      } finally {\n        // ignoring the error from close(2) is a bad practice, but at\n        // this point we already have an error, don't need another one\n        if (threw) {\n          try {\n            this[CLOSE](fd, function () {});\n          } catch (er) {}\n        }\n      }\n    }\n  }, {\n    key: CLOSE,\n    value: function value(fd, cb) {\n      fs.closeSync(fd);\n      cb();\n    }\n  }]);\n\n  return WriteEntrySync;\n}(WriteEntry);\n\nvar WriteEntryTar = warner( /*#__PURE__*/function (_MiniPass2) {\n  _inherits(WriteEntryTar, _MiniPass2);\n\n  var _super3 = _createSuper(WriteEntryTar);\n\n  function WriteEntryTar(readEntry, opt) {\n    var _thisSuper, _thisSuper2, _this7;\n\n    _classCallCheck(this, WriteEntryTar);\n\n    opt = opt || {};\n    _this7 = _super3.call(this, opt);\n    _this7.preservePaths = !!opt.preservePaths;\n    _this7.portable = !!opt.portable;\n    _this7.strict = !!opt.strict;\n    _this7.noPax = !!opt.noPax;\n    _this7.noMtime = !!opt.noMtime;\n    _this7.readEntry = readEntry;\n    _this7.type = readEntry.type;\n    if (_this7.type === 'Directory' && _this7.portable) _this7.noMtime = true;\n    _this7.path = readEntry.path;\n    _this7.mode = _this7[MODE](readEntry.mode);\n    _this7.uid = _this7.portable ? null : readEntry.uid;\n    _this7.gid = _this7.portable ? null : readEntry.gid;\n    _this7.uname = _this7.portable ? null : readEntry.uname;\n    _this7.gname = _this7.portable ? null : readEntry.gname;\n    _this7.size = readEntry.size;\n    _this7.mtime = _this7.noMtime ? null : opt.mtime || readEntry.mtime;\n    _this7.atime = _this7.portable ? null : readEntry.atime;\n    _this7.ctime = _this7.portable ? null : readEntry.ctime;\n    _this7.linkpath = readEntry.linkpath;\n    if (typeof opt.onwarn === 'function') _this7.on('warn', opt.onwarn);\n    var pathWarn = false;\n\n    if (path.isAbsolute(_this7.path) && !_this7.preservePaths) {\n      var parsed = path.parse(_this7.path);\n      pathWarn = parsed.root;\n      _this7.path = _this7.path.substr(parsed.root.length);\n    }\n\n    _this7.remain = readEntry.size;\n    _this7.blockRemain = readEntry.startBlockSize;\n    _this7.header = new Header({\n      path: _this7.path,\n      linkpath: _this7.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: _this7.mode,\n      uid: _this7.portable ? null : _this7.uid,\n      gid: _this7.portable ? null : _this7.gid,\n      size: _this7.size,\n      mtime: _this7.noMtime ? null : _this7.mtime,\n      type: _this7.type,\n      uname: _this7.portable ? null : _this7.uname,\n      atime: _this7.portable ? null : _this7.atime,\n      ctime: _this7.portable ? null : _this7.ctime\n    });\n\n    if (pathWarn) {\n      _this7.warn('TAR_ENTRY_INFO', \"stripping \".concat(pathWarn, \" from absolute path\"), {\n        entry: _assertThisInitialized(_this7),\n        path: pathWarn + _this7.path\n      });\n    }\n\n    if (_this7.header.encode() && !_this7.noPax) {\n      _get((_thisSuper = _assertThisInitialized(_this7), _getPrototypeOf(WriteEntryTar.prototype)), \"write\", _thisSuper).call(_thisSuper, new Pax({\n        atime: _this7.portable ? null : _this7.atime,\n        ctime: _this7.portable ? null : _this7.ctime,\n        gid: _this7.portable ? null : _this7.gid,\n        mtime: _this7.noMtime ? null : _this7.mtime,\n        path: _this7.path,\n        linkpath: _this7.linkpath,\n        size: _this7.size,\n        uid: _this7.portable ? null : _this7.uid,\n        uname: _this7.portable ? null : _this7.uname,\n        dev: _this7.portable ? null : _this7.readEntry.dev,\n        ino: _this7.portable ? null : _this7.readEntry.ino,\n        nlink: _this7.portable ? null : _this7.readEntry.nlink\n      }).encode());\n    }\n\n    _get((_thisSuper2 = _assertThisInitialized(_this7), _getPrototypeOf(WriteEntryTar.prototype)), \"write\", _thisSuper2).call(_thisSuper2, _this7.header.block);\n\n    readEntry.pipe(_assertThisInitialized(_this7));\n    return _this7;\n  }\n\n  _createClass(WriteEntryTar, [{\n    key: MODE,\n    value: function value(mode) {\n      return modeFix(mode, this.type === 'Directory', this.portable);\n    }\n  }, {\n    key: \"write\",\n    value: function write(data) {\n      var writeLen = data.length;\n      if (writeLen > this.blockRemain) throw new Error('writing more to entry than is appropriate');\n      this.blockRemain -= writeLen;\n      return _get(_getPrototypeOf(WriteEntryTar.prototype), \"write\", this).call(this, data);\n    }\n  }, {\n    key: \"end\",\n    value: function end() {\n      if (this.blockRemain) this.write(Buffer.alloc(this.blockRemain));\n      return _get(_getPrototypeOf(WriteEntryTar.prototype), \"end\", this).call(this);\n    }\n  }]);\n\n  return WriteEntryTar;\n}(MiniPass));\nWriteEntry.Sync = WriteEntrySync;\nWriteEntry.Tar = WriteEntryTar;\n\nvar getType = function getType(stat) {\n  return stat.isFile() ? 'File' : stat.isDirectory() ? 'Directory' : stat.isSymbolicLink() ? 'SymbolicLink' : 'Unsupported';\n};\n\nmodule.exports = WriteEntry;","map":{"version":3,"sources":["/Users/austenhughes/The-Baffoonery/node_modules/tar/lib/write-entry.js"],"names":["MiniPass","require","Pax","Header","fs","path","maxReadSize","PROCESS","Symbol","FILE","DIRECTORY","SYMLINK","HARDLINK","HEADER","READ","LSTAT","ONLSTAT","ONREAD","ONREADLINK","OPENFILE","ONOPENFILE","CLOSE","MODE","warner","winchars","modeFix","WriteEntry","p","opt","TypeError","portable","myuid","process","getuid","myuser","env","USER","linkCache","Map","statCache","preservePaths","cwd","strict","noPax","noMtime","mtime","onwarn","on","pathWarn","win32","isAbsolute","parsed","parse","substr","root","length","platform","decode","replace","absolute","resolve","warn","entry","has","get","lstat","er","stat","emit","set","isFile","size","type","getType","end","mode","header","linkpath","uid","gid","uname","atime","ctime","encode","write","dev","ino","nlink","block","readlink","relative","linkKey","indexOf","open","fd","blockLen","Math","ceil","bufLen","min","buf","Buffer","allocUnsafe","offset","pos","remain","blockRemain","read","bytesRead","cb","close","Error","syscall","code","i","writeBuf","slice","alloc","WriteEntrySync","lstatSync","readlinkSync","openSync","threw","readSync","closeSync","WriteEntryTar","readEntry","gname","startBlockSize","pipe","data","writeLen","Sync","Tar","isDirectory","isSymbolicLink","module","exports"],"mappings":"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","sourcesContent":["'use strict'\nconst MiniPass = require('minipass')\nconst Pax = require('./pax.js')\nconst Header = require('./header.js')\nconst fs = require('fs')\nconst path = require('path')\n\nconst maxReadSize = 16 * 1024 * 1024\nconst PROCESS = Symbol('process')\nconst FILE = Symbol('file')\nconst DIRECTORY = Symbol('directory')\nconst SYMLINK = Symbol('symlink')\nconst HARDLINK = Symbol('hardlink')\nconst HEADER = Symbol('header')\nconst READ = Symbol('read')\nconst LSTAT = Symbol('lstat')\nconst ONLSTAT = Symbol('onlstat')\nconst ONREAD = Symbol('onread')\nconst ONREADLINK = Symbol('onreadlink')\nconst OPENFILE = Symbol('openfile')\nconst ONOPENFILE = Symbol('onopenfile')\nconst CLOSE = Symbol('close')\nconst MODE = Symbol('mode')\nconst warner = require('./warn-mixin.js')\nconst winchars = require('./winchars.js')\n\nconst modeFix = require('./mode-fix.js')\n\nconst WriteEntry = warner(class WriteEntry extends MiniPass {\n  constructor (p, opt) {\n    opt = opt || {}\n    super(opt)\n    if (typeof p !== 'string')\n      throw new TypeError('path is required')\n    this.path = p\n    // suppress atime, ctime, uid, gid, uname, gname\n    this.portable = !!opt.portable\n    // until node has builtin pwnam functions, this'll have to do\n    this.myuid = process.getuid && process.getuid()\n    this.myuser = process.env.USER || ''\n    this.maxReadSize = opt.maxReadSize || maxReadSize\n    this.linkCache = opt.linkCache || new Map()\n    this.statCache = opt.statCache || new Map()\n    this.preservePaths = !!opt.preservePaths\n    this.cwd = opt.cwd || process.cwd()\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.noMtime = !!opt.noMtime\n    this.mtime = opt.mtime || null\n\n    if (typeof opt.onwarn === 'function')\n      this.on('warn', opt.onwarn)\n\n    let pathWarn = false\n    if (!this.preservePaths && path.win32.isAbsolute(p)) {\n      // absolutes on posix are also absolutes on win32\n      // so we only need to test this one to get both\n      const parsed = path.win32.parse(p)\n      this.path = p.substr(parsed.root.length)\n      pathWarn = parsed.root\n    }\n\n    this.win32 = !!opt.win32 || process.platform === 'win32'\n    if (this.win32) {\n      this.path = winchars.decode(this.path.replace(/\\\\/g, '/'))\n      p = p.replace(/\\\\/g, '/')\n    }\n\n    this.absolute = opt.absolute || path.resolve(this.cwd, p)\n\n    if (this.path === '')\n      this.path = './'\n\n    if (pathWarn) {\n      this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {\n        entry: this,\n        path: pathWarn + this.path,\n      })\n    }\n\n    if (this.statCache.has(this.absolute))\n      this[ONLSTAT](this.statCache.get(this.absolute))\n    else\n      this[LSTAT]()\n  }\n\n  [LSTAT] () {\n    fs.lstat(this.absolute, (er, stat) => {\n      if (er)\n        return this.emit('error', er)\n      this[ONLSTAT](stat)\n    })\n  }\n\n  [ONLSTAT] (stat) {\n    this.statCache.set(this.absolute, stat)\n    this.stat = stat\n    if (!stat.isFile())\n      stat.size = 0\n    this.type = getType(stat)\n    this.emit('stat', stat)\n    this[PROCESS]()\n  }\n\n  [PROCESS] () {\n    switch (this.type) {\n      case 'File': return this[FILE]()\n      case 'Directory': return this[DIRECTORY]()\n      case 'SymbolicLink': return this[SYMLINK]()\n      // unsupported types are ignored.\n      default: return this.end()\n    }\n  }\n\n  [MODE] (mode) {\n    return modeFix(mode, this.type === 'Directory', this.portable)\n  }\n\n  [HEADER] () {\n    if (this.type === 'Directory' && this.portable)\n      this.noMtime = true\n\n    this.header = new Header({\n      path: this.path,\n      linkpath: this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this[MODE](this.stat.mode),\n      uid: this.portable ? null : this.stat.uid,\n      gid: this.portable ? null : this.stat.gid,\n      size: this.stat.size,\n      mtime: this.noMtime ? null : this.mtime || this.stat.mtime,\n      type: this.type,\n      uname: this.portable ? null :\n      this.stat.uid === this.myuid ? this.myuser : '',\n      atime: this.portable ? null : this.stat.atime,\n      ctime: this.portable ? null : this.stat.ctime,\n    })\n\n    if (this.header.encode() && !this.noPax) {\n      this.write(new Pax({\n        atime: this.portable ? null : this.header.atime,\n        ctime: this.portable ? null : this.header.ctime,\n        gid: this.portable ? null : this.header.gid,\n        mtime: this.noMtime ? null : this.mtime || this.header.mtime,\n        path: this.path,\n        linkpath: this.linkpath,\n        size: this.header.size,\n        uid: this.portable ? null : this.header.uid,\n        uname: this.portable ? null : this.header.uname,\n        dev: this.portable ? null : this.stat.dev,\n        ino: this.portable ? null : this.stat.ino,\n        nlink: this.portable ? null : this.stat.nlink,\n      }).encode())\n    }\n    this.write(this.header.block)\n  }\n\n  [DIRECTORY] () {\n    if (this.path.substr(-1) !== '/')\n      this.path += '/'\n    this.stat.size = 0\n    this[HEADER]()\n    this.end()\n  }\n\n  [SYMLINK] () {\n    fs.readlink(this.absolute, (er, linkpath) => {\n      if (er)\n        return this.emit('error', er)\n      this[ONREADLINK](linkpath)\n    })\n  }\n\n  [ONREADLINK] (linkpath) {\n    this.linkpath = linkpath.replace(/\\\\/g, '/')\n    this[HEADER]()\n    this.end()\n  }\n\n  [HARDLINK] (linkpath) {\n    this.type = 'Link'\n    this.linkpath = path.relative(this.cwd, linkpath).replace(/\\\\/g, '/')\n    this.stat.size = 0\n    this[HEADER]()\n    this.end()\n  }\n\n  [FILE] () {\n    if (this.stat.nlink > 1) {\n      const linkKey = this.stat.dev + ':' + this.stat.ino\n      if (this.linkCache.has(linkKey)) {\n        const linkpath = this.linkCache.get(linkKey)\n        if (linkpath.indexOf(this.cwd) === 0)\n          return this[HARDLINK](linkpath)\n      }\n      this.linkCache.set(linkKey, this.absolute)\n    }\n\n    this[HEADER]()\n    if (this.stat.size === 0)\n      return this.end()\n\n    this[OPENFILE]()\n  }\n\n  [OPENFILE] () {\n    fs.open(this.absolute, 'r', (er, fd) => {\n      if (er)\n        return this.emit('error', er)\n      this[ONOPENFILE](fd)\n    })\n  }\n\n  [ONOPENFILE] (fd) {\n    const blockLen = 512 * Math.ceil(this.stat.size / 512)\n    const bufLen = Math.min(blockLen, this.maxReadSize)\n    const buf = Buffer.allocUnsafe(bufLen)\n    this[READ](fd, buf, 0, buf.length, 0, this.stat.size, blockLen)\n  }\n\n  [READ] (fd, buf, offset, length, pos, remain, blockRemain) {\n    fs.read(fd, buf, offset, length, pos, (er, bytesRead) => {\n      if (er) {\n        // ignoring the error from close(2) is a bad practice, but at\n        // this point we already have an error, don't need another one\n        return this[CLOSE](fd, () => this.emit('error', er))\n      }\n      this[ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead)\n    })\n  }\n\n  [CLOSE] (fd, cb) {\n    fs.close(fd, cb)\n  }\n\n  [ONREAD] (fd, buf, offset, length, pos, remain, blockRemain, bytesRead) {\n    if (bytesRead <= 0 && remain > 0) {\n      const er = new Error('encountered unexpected EOF')\n      er.path = this.absolute\n      er.syscall = 'read'\n      er.code = 'EOF'\n      return this[CLOSE](fd, () => this.emit('error', er))\n    }\n\n    if (bytesRead > remain) {\n      const er = new Error('did not encounter expected EOF')\n      er.path = this.absolute\n      er.syscall = 'read'\n      er.code = 'EOF'\n      return this[CLOSE](fd, () => this.emit('error', er))\n    }\n\n    // null out the rest of the buffer, if we could fit the block padding\n    if (bytesRead === remain) {\n      for (let i = bytesRead; i < length && bytesRead < blockRemain; i++) {\n        buf[i + offset] = 0\n        bytesRead++\n        remain++\n      }\n    }\n\n    const writeBuf = offset === 0 && bytesRead === buf.length ?\n      buf : buf.slice(offset, offset + bytesRead)\n    remain -= bytesRead\n    blockRemain -= bytesRead\n    pos += bytesRead\n    offset += bytesRead\n\n    this.write(writeBuf)\n\n    if (!remain) {\n      if (blockRemain)\n        this.write(Buffer.alloc(blockRemain))\n      return this[CLOSE](fd, er => er ? this.emit('error', er) : this.end())\n    }\n\n    if (offset >= length) {\n      buf = Buffer.allocUnsafe(length)\n      offset = 0\n    }\n    length = buf.length - offset\n    this[READ](fd, buf, offset, length, pos, remain, blockRemain)\n  }\n})\n\nclass WriteEntrySync extends WriteEntry {\n  [LSTAT] () {\n    this[ONLSTAT](fs.lstatSync(this.absolute))\n  }\n\n  [SYMLINK] () {\n    this[ONREADLINK](fs.readlinkSync(this.absolute))\n  }\n\n  [OPENFILE] () {\n    this[ONOPENFILE](fs.openSync(this.absolute, 'r'))\n  }\n\n  [READ] (fd, buf, offset, length, pos, remain, blockRemain) {\n    let threw = true\n    try {\n      const bytesRead = fs.readSync(fd, buf, offset, length, pos)\n      this[ONREAD](fd, buf, offset, length, pos, remain, blockRemain, bytesRead)\n      threw = false\n    } finally {\n      // ignoring the error from close(2) is a bad practice, but at\n      // this point we already have an error, don't need another one\n      if (threw) {\n        try {\n          this[CLOSE](fd, () => {})\n        } catch (er) {}\n      }\n    }\n  }\n\n  [CLOSE] (fd, cb) {\n    fs.closeSync(fd)\n    cb()\n  }\n}\n\nconst WriteEntryTar = warner(class WriteEntryTar extends MiniPass {\n  constructor (readEntry, opt) {\n    opt = opt || {}\n    super(opt)\n    this.preservePaths = !!opt.preservePaths\n    this.portable = !!opt.portable\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.noMtime = !!opt.noMtime\n\n    this.readEntry = readEntry\n    this.type = readEntry.type\n    if (this.type === 'Directory' && this.portable)\n      this.noMtime = true\n\n    this.path = readEntry.path\n    this.mode = this[MODE](readEntry.mode)\n    this.uid = this.portable ? null : readEntry.uid\n    this.gid = this.portable ? null : readEntry.gid\n    this.uname = this.portable ? null : readEntry.uname\n    this.gname = this.portable ? null : readEntry.gname\n    this.size = readEntry.size\n    this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime\n    this.atime = this.portable ? null : readEntry.atime\n    this.ctime = this.portable ? null : readEntry.ctime\n    this.linkpath = readEntry.linkpath\n\n    if (typeof opt.onwarn === 'function')\n      this.on('warn', opt.onwarn)\n\n    let pathWarn = false\n    if (path.isAbsolute(this.path) && !this.preservePaths) {\n      const parsed = path.parse(this.path)\n      pathWarn = parsed.root\n      this.path = this.path.substr(parsed.root.length)\n    }\n\n    this.remain = readEntry.size\n    this.blockRemain = readEntry.startBlockSize\n\n    this.header = new Header({\n      path: this.path,\n      linkpath: this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this.mode,\n      uid: this.portable ? null : this.uid,\n      gid: this.portable ? null : this.gid,\n      size: this.size,\n      mtime: this.noMtime ? null : this.mtime,\n      type: this.type,\n      uname: this.portable ? null : this.uname,\n      atime: this.portable ? null : this.atime,\n      ctime: this.portable ? null : this.ctime,\n    })\n\n    if (pathWarn) {\n      this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {\n        entry: this,\n        path: pathWarn + this.path,\n      })\n    }\n\n    if (this.header.encode() && !this.noPax) {\n      super.write(new Pax({\n        atime: this.portable ? null : this.atime,\n        ctime: this.portable ? null : this.ctime,\n        gid: this.portable ? null : this.gid,\n        mtime: this.noMtime ? null : this.mtime,\n        path: this.path,\n        linkpath: this.linkpath,\n        size: this.size,\n        uid: this.portable ? null : this.uid,\n        uname: this.portable ? null : this.uname,\n        dev: this.portable ? null : this.readEntry.dev,\n        ino: this.portable ? null : this.readEntry.ino,\n        nlink: this.portable ? null : this.readEntry.nlink,\n      }).encode())\n    }\n\n    super.write(this.header.block)\n    readEntry.pipe(this)\n  }\n\n  [MODE] (mode) {\n    return modeFix(mode, this.type === 'Directory', this.portable)\n  }\n\n  write (data) {\n    const writeLen = data.length\n    if (writeLen > this.blockRemain)\n      throw new Error('writing more to entry than is appropriate')\n    this.blockRemain -= writeLen\n    return super.write(data)\n  }\n\n  end () {\n    if (this.blockRemain)\n      this.write(Buffer.alloc(this.blockRemain))\n    return super.end()\n  }\n})\n\nWriteEntry.Sync = WriteEntrySync\nWriteEntry.Tar = WriteEntryTar\n\nconst getType = stat =>\n  stat.isFile() ? 'File'\n  : stat.isDirectory() ? 'Directory'\n  : stat.isSymbolicLink() ? 'SymbolicLink'\n  : 'Unsupported'\n\nmodule.exports = WriteEntry\n"]},"metadata":{},"sourceType":"script"}