{"ast":null,"code":"'use strict'; // wrapper around mkdirp for tar's needs.\n// TODO: This should probably be a class, not functionally\n// passing around state in a gazillion args.\n\nvar _classCallCheck = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _wrapNativeSuper = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\n\nvar mkdirp = require('mkdirp');\n\nvar fs = require('fs');\n\nvar path = require('path');\n\nvar chownr = require('chownr');\n\nvar SymlinkError = /*#__PURE__*/function (_Error) {\n  _inherits(SymlinkError, _Error);\n\n  var _super = _createSuper(SymlinkError);\n\n  function SymlinkError(symlink, path) {\n    var _this;\n\n    _classCallCheck(this, SymlinkError);\n\n    _this = _super.call(this, 'Cannot extract through symbolic link');\n    _this.path = path;\n    _this.symlink = symlink;\n    return _this;\n  }\n\n  _createClass(SymlinkError, [{\n    key: \"name\",\n    get: function get() {\n      return 'SylinkError';\n    }\n  }]);\n\n  return SymlinkError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar CwdError = /*#__PURE__*/function (_Error2) {\n  _inherits(CwdError, _Error2);\n\n  var _super2 = _createSuper(CwdError);\n\n  function CwdError(path, code) {\n    var _this2;\n\n    _classCallCheck(this, CwdError);\n\n    _this2 = _super2.call(this, code + ': Cannot cd into \\'' + path + '\\'');\n    _this2.path = path;\n    _this2.code = code;\n    return _this2;\n  }\n\n  _createClass(CwdError, [{\n    key: \"name\",\n    get: function get() {\n      return 'CwdError';\n    }\n  }]);\n\n  return CwdError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nmodule.exports = function (dir, opt, cb) {\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  var umask = opt.umask;\n  var mode = opt.mode | 448;\n  var needChmod = (mode & umask) !== 0;\n  var uid = opt.uid;\n  var gid = opt.gid;\n  var doChown = typeof uid === 'number' && typeof gid === 'number' && (uid !== opt.processUid || gid !== opt.processGid);\n  var preserve = opt.preserve;\n  var unlink = opt.unlink;\n  var cache = opt.cache;\n  var cwd = opt.cwd;\n\n  var done = function done(er, created) {\n    if (er) cb(er);else {\n      cache.set(dir, true);\n      if (created && doChown) chownr(created, uid, gid, function (er) {\n        return done(er);\n      });else if (needChmod) fs.chmod(dir, mode, cb);else cb();\n    }\n  };\n\n  if (cache && cache.get(dir) === true) return done();\n\n  if (dir === cwd) {\n    return fs.stat(dir, function (er, st) {\n      if (er || !st.isDirectory()) er = new CwdError(dir, er && er.code || 'ENOTDIR');\n      done(er);\n    });\n  }\n\n  if (preserve) return mkdirp(dir, {\n    mode: mode\n  }).then(function (made) {\n    return done(null, made);\n  }, done);\n  var sub = path.relative(cwd, dir);\n  var parts = sub.split(/\\/|\\\\/);\n  mkdir_(cwd, parts, mode, cache, unlink, cwd, null, done);\n};\n\nvar mkdir_ = function mkdir_(base, parts, mode, cache, unlink, cwd, created, cb) {\n  if (!parts.length) return cb(null, created);\n  var p = parts.shift();\n  var part = base + '/' + p;\n  if (cache.get(part)) return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);\n  fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));\n};\n\nvar onmkdir = function onmkdir(part, parts, mode, cache, unlink, cwd, created, cb) {\n  return function (er) {\n    if (er) {\n      if (er.path && path.dirname(er.path) === cwd && (er.code === 'ENOTDIR' || er.code === 'ENOENT')) return cb(new CwdError(cwd, er.code));\n      fs.lstat(part, function (statEr, st) {\n        if (statEr) cb(statEr);else if (st.isDirectory()) mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);else if (unlink) {\n          fs.unlink(part, function (er) {\n            if (er) return cb(er);\n            fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));\n          });\n        } else if (st.isSymbolicLink()) return cb(new SymlinkError(part, part + '/' + parts.join('/')));else cb(er);\n      });\n    } else {\n      created = created || part;\n      mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);\n    }\n  };\n};\n\nmodule.exports.sync = function (dir, opt) {\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  var umask = opt.umask;\n  var mode = opt.mode | 448;\n  var needChmod = (mode & umask) !== 0;\n  var uid = opt.uid;\n  var gid = opt.gid;\n  var doChown = typeof uid === 'number' && typeof gid === 'number' && (uid !== opt.processUid || gid !== opt.processGid);\n  var preserve = opt.preserve;\n  var unlink = opt.unlink;\n  var cache = opt.cache;\n  var cwd = opt.cwd;\n\n  var done = function done(created) {\n    cache.set(dir, true);\n    if (created && doChown) chownr.sync(created, uid, gid);\n    if (needChmod) fs.chmodSync(dir, mode);\n  };\n\n  if (cache && cache.get(dir) === true) return done();\n\n  if (dir === cwd) {\n    var ok = false;\n    var code = 'ENOTDIR';\n\n    try {\n      ok = fs.statSync(dir).isDirectory();\n    } catch (er) {\n      code = er.code;\n    } finally {\n      if (!ok) throw new CwdError(dir, code);\n    }\n\n    done();\n    return;\n  }\n\n  if (preserve) return done(mkdirp.sync(dir, mode));\n  var sub = path.relative(cwd, dir);\n  var parts = sub.split(/\\/|\\\\/);\n  var created = null;\n\n  for (var p = parts.shift(), part = cwd; p && (part += '/' + p); p = parts.shift()) {\n    if (cache.get(part)) continue;\n\n    try {\n      fs.mkdirSync(part, mode);\n      created = created || part;\n      cache.set(part, true);\n    } catch (er) {\n      if (er.path && path.dirname(er.path) === cwd && (er.code === 'ENOTDIR' || er.code === 'ENOENT')) return new CwdError(cwd, er.code);\n      var st = fs.lstatSync(part);\n\n      if (st.isDirectory()) {\n        cache.set(part, true);\n        continue;\n      } else if (unlink) {\n        fs.unlinkSync(part);\n        fs.mkdirSync(part, mode);\n        created = created || part;\n        cache.set(part, true);\n        continue;\n      } else if (st.isSymbolicLink()) return new SymlinkError(part, part + '/' + parts.join('/'));\n    }\n  }\n\n  return done(created);\n};","map":{"version":3,"sources":["/Users/austenhughes/The-Baffoonery/node_modules/tar/lib/mkdir.js"],"names":["mkdirp","require","fs","path","chownr","SymlinkError","symlink","Error","CwdError","code","module","exports","dir","opt","cb","umask","mode","needChmod","uid","gid","doChown","processUid","processGid","preserve","unlink","cache","cwd","done","er","created","set","chmod","get","stat","st","isDirectory","then","made","sub","relative","parts","split","mkdir_","base","length","p","shift","part","mkdir","onmkdir","dirname","lstat","statEr","isSymbolicLink","join","sync","chmodSync","ok","statSync","mkdirSync","lstatSync","unlinkSync"],"mappings":"AAAA,a,CACA;AAEA;AACA;;;;;;;;;;;;AAEA,IAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AACA,IAAMC,EAAE,GAAGD,OAAO,CAAC,IAAD,CAAlB;;AACA,IAAME,IAAI,GAAGF,OAAO,CAAC,MAAD,CAApB;;AACA,IAAMG,MAAM,GAAGH,OAAO,CAAC,QAAD,CAAtB;;IAEMI,Y;;;;;AACJ,wBAAaC,OAAb,EAAsBH,IAAtB,EAA4B;AAAA;;AAAA;;AAC1B,8BAAM,sCAAN;AACA,UAAKA,IAAL,GAAYA,IAAZ;AACA,UAAKG,OAAL,GAAeA,OAAf;AAH0B;AAI3B;;;;SAED,eAAY;AACV,aAAO,aAAP;AACD;;;;iCATwBC,K;;IAYrBC,Q;;;;;AACJ,oBAAaL,IAAb,EAAmBM,IAAnB,EAAyB;AAAA;;AAAA;;AACvB,gCAAMA,IAAI,GAAG,qBAAP,GAA+BN,IAA/B,GAAsC,IAA5C;AACA,WAAKA,IAAL,GAAYA,IAAZ;AACA,WAAKM,IAAL,GAAYA,IAAZ;AAHuB;AAIxB;;;;SAED,eAAY;AACV,aAAO,UAAP;AACD;;;;iCAToBF,K;;AAYvBG,MAAM,CAACC,OAAP,GAAiB,UAACC,GAAD,EAAMC,GAAN,EAAWC,EAAX,EAAkB;AACjC;AACA;AACA,MAAMC,KAAK,GAAGF,GAAG,CAACE,KAAlB;AACA,MAAMC,IAAI,GAAGH,GAAG,CAACG,IAAJ,GAAW,GAAxB;AACA,MAAMC,SAAS,GAAG,CAACD,IAAI,GAAGD,KAAR,MAAmB,CAArC;AAEA,MAAMG,GAAG,GAAGL,GAAG,CAACK,GAAhB;AACA,MAAMC,GAAG,GAAGN,GAAG,CAACM,GAAhB;AACA,MAAMC,OAAO,GAAG,OAAOF,GAAP,KAAe,QAAf,IACd,OAAOC,GAAP,KAAe,QADD,KAEbD,GAAG,KAAKL,GAAG,CAACQ,UAAZ,IAA0BF,GAAG,KAAKN,GAAG,CAACS,UAFzB,CAAhB;AAIA,MAAMC,QAAQ,GAAGV,GAAG,CAACU,QAArB;AACA,MAAMC,MAAM,GAAGX,GAAG,CAACW,MAAnB;AACA,MAAMC,KAAK,GAAGZ,GAAG,CAACY,KAAlB;AACA,MAAMC,GAAG,GAAGb,GAAG,CAACa,GAAhB;;AAEA,MAAMC,IAAI,GAAG,SAAPA,IAAO,CAACC,EAAD,EAAKC,OAAL,EAAiB;AAC5B,QAAID,EAAJ,EACEd,EAAE,CAACc,EAAD,CAAF,CADF,KAEK;AACHH,MAAAA,KAAK,CAACK,GAAN,CAAUlB,GAAV,EAAe,IAAf;AACA,UAAIiB,OAAO,IAAIT,OAAf,EACEhB,MAAM,CAACyB,OAAD,EAAUX,GAAV,EAAeC,GAAf,EAAoB,UAAAS,EAAE;AAAA,eAAID,IAAI,CAACC,EAAD,CAAR;AAAA,OAAtB,CAAN,CADF,KAEK,IAAIX,SAAJ,EACHf,EAAE,CAAC6B,KAAH,CAASnB,GAAT,EAAcI,IAAd,EAAoBF,EAApB,EADG,KAGHA,EAAE;AACL;AACF,GAZD;;AAcA,MAAIW,KAAK,IAAIA,KAAK,CAACO,GAAN,CAAUpB,GAAV,MAAmB,IAAhC,EACE,OAAOe,IAAI,EAAX;;AAEF,MAAIf,GAAG,KAAKc,GAAZ,EAAiB;AACf,WAAOxB,EAAE,CAAC+B,IAAH,CAAQrB,GAAR,EAAa,UAACgB,EAAD,EAAKM,EAAL,EAAY;AAC9B,UAAIN,EAAE,IAAI,CAACM,EAAE,CAACC,WAAH,EAAX,EACEP,EAAE,GAAG,IAAIpB,QAAJ,CAAaI,GAAb,EAAkBgB,EAAE,IAAIA,EAAE,CAACnB,IAAT,IAAiB,SAAnC,CAAL;AACFkB,MAAAA,IAAI,CAACC,EAAD,CAAJ;AACD,KAJM,CAAP;AAKD;;AAED,MAAIL,QAAJ,EACE,OAAOvB,MAAM,CAACY,GAAD,EAAM;AAACI,IAAAA,IAAI,EAAJA;AAAD,GAAN,CAAN,CAAoBoB,IAApB,CAAyB,UAAAC,IAAI;AAAA,WAAIV,IAAI,CAAC,IAAD,EAAOU,IAAP,CAAR;AAAA,GAA7B,EAAmDV,IAAnD,CAAP;AAEF,MAAMW,GAAG,GAAGnC,IAAI,CAACoC,QAAL,CAAcb,GAAd,EAAmBd,GAAnB,CAAZ;AACA,MAAM4B,KAAK,GAAGF,GAAG,CAACG,KAAJ,CAAU,OAAV,CAAd;AACAC,EAAAA,MAAM,CAAChB,GAAD,EAAMc,KAAN,EAAaxB,IAAb,EAAmBS,KAAnB,EAA0BD,MAA1B,EAAkCE,GAAlC,EAAuC,IAAvC,EAA6CC,IAA7C,CAAN;AACD,CAjDD;;AAmDA,IAAMe,MAAM,GAAG,SAATA,MAAS,CAACC,IAAD,EAAOH,KAAP,EAAcxB,IAAd,EAAoBS,KAApB,EAA2BD,MAA3B,EAAmCE,GAAnC,EAAwCG,OAAxC,EAAiDf,EAAjD,EAAwD;AACrE,MAAI,CAAC0B,KAAK,CAACI,MAAX,EACE,OAAO9B,EAAE,CAAC,IAAD,EAAOe,OAAP,CAAT;AACF,MAAMgB,CAAC,GAAGL,KAAK,CAACM,KAAN,EAAV;AACA,MAAMC,IAAI,GAAGJ,IAAI,GAAG,GAAP,GAAaE,CAA1B;AACA,MAAIpB,KAAK,CAACO,GAAN,CAAUe,IAAV,CAAJ,EACE,OAAOL,MAAM,CAACK,IAAD,EAAOP,KAAP,EAAcxB,IAAd,EAAoBS,KAApB,EAA2BD,MAA3B,EAAmCE,GAAnC,EAAwCG,OAAxC,EAAiDf,EAAjD,CAAb;AACFZ,EAAAA,EAAE,CAAC8C,KAAH,CAASD,IAAT,EAAe/B,IAAf,EAAqBiC,OAAO,CAACF,IAAD,EAAOP,KAAP,EAAcxB,IAAd,EAAoBS,KAApB,EAA2BD,MAA3B,EAAmCE,GAAnC,EAAwCG,OAAxC,EAAiDf,EAAjD,CAA5B;AACD,CARD;;AAUA,IAAMmC,OAAO,GAAG,SAAVA,OAAU,CAACF,IAAD,EAAOP,KAAP,EAAcxB,IAAd,EAAoBS,KAApB,EAA2BD,MAA3B,EAAmCE,GAAnC,EAAwCG,OAAxC,EAAiDf,EAAjD;AAAA,SAAwD,UAAAc,EAAE,EAAI;AAC5E,QAAIA,EAAJ,EAAQ;AACN,UAAIA,EAAE,CAACzB,IAAH,IAAWA,IAAI,CAAC+C,OAAL,CAAatB,EAAE,CAACzB,IAAhB,MAA0BuB,GAArC,KACCE,EAAE,CAACnB,IAAH,KAAY,SAAZ,IAAyBmB,EAAE,CAACnB,IAAH,KAAY,QADtC,CAAJ,EAEE,OAAOK,EAAE,CAAC,IAAIN,QAAJ,CAAakB,GAAb,EAAkBE,EAAE,CAACnB,IAArB,CAAD,CAAT;AAEFP,MAAAA,EAAE,CAACiD,KAAH,CAASJ,IAAT,EAAe,UAACK,MAAD,EAASlB,EAAT,EAAgB;AAC7B,YAAIkB,MAAJ,EACEtC,EAAE,CAACsC,MAAD,CAAF,CADF,KAEK,IAAIlB,EAAE,CAACC,WAAH,EAAJ,EACHO,MAAM,CAACK,IAAD,EAAOP,KAAP,EAAcxB,IAAd,EAAoBS,KAApB,EAA2BD,MAA3B,EAAmCE,GAAnC,EAAwCG,OAAxC,EAAiDf,EAAjD,CAAN,CADG,KAEA,IAAIU,MAAJ,EAAY;AACftB,UAAAA,EAAE,CAACsB,MAAH,CAAUuB,IAAV,EAAgB,UAAAnB,EAAE,EAAI;AACpB,gBAAIA,EAAJ,EACE,OAAOd,EAAE,CAACc,EAAD,CAAT;AACF1B,YAAAA,EAAE,CAAC8C,KAAH,CAASD,IAAT,EAAe/B,IAAf,EAAqBiC,OAAO,CAACF,IAAD,EAAOP,KAAP,EAAcxB,IAAd,EAAoBS,KAApB,EAA2BD,MAA3B,EAAmCE,GAAnC,EAAwCG,OAAxC,EAAiDf,EAAjD,CAA5B;AACD,WAJD;AAKD,SANI,MAME,IAAIoB,EAAE,CAACmB,cAAH,EAAJ,EACL,OAAOvC,EAAE,CAAC,IAAIT,YAAJ,CAAiB0C,IAAjB,EAAuBA,IAAI,GAAG,GAAP,GAAaP,KAAK,CAACc,IAAN,CAAW,GAAX,CAApC,CAAD,CAAT,CADK,KAGLxC,EAAE,CAACc,EAAD,CAAF;AACH,OAfD;AAgBD,KArBD,MAqBO;AACLC,MAAAA,OAAO,GAAGA,OAAO,IAAIkB,IAArB;AACAL,MAAAA,MAAM,CAACK,IAAD,EAAOP,KAAP,EAAcxB,IAAd,EAAoBS,KAApB,EAA2BD,MAA3B,EAAmCE,GAAnC,EAAwCG,OAAxC,EAAiDf,EAAjD,CAAN;AACD;AACF,GA1Be;AAAA,CAAhB;;AA4BAJ,MAAM,CAACC,OAAP,CAAe4C,IAAf,GAAsB,UAAC3C,GAAD,EAAMC,GAAN,EAAc;AAClC;AACA;AACA,MAAME,KAAK,GAAGF,GAAG,CAACE,KAAlB;AACA,MAAMC,IAAI,GAAGH,GAAG,CAACG,IAAJ,GAAW,GAAxB;AACA,MAAMC,SAAS,GAAG,CAACD,IAAI,GAAGD,KAAR,MAAmB,CAArC;AAEA,MAAMG,GAAG,GAAGL,GAAG,CAACK,GAAhB;AACA,MAAMC,GAAG,GAAGN,GAAG,CAACM,GAAhB;AACA,MAAMC,OAAO,GAAG,OAAOF,GAAP,KAAe,QAAf,IACd,OAAOC,GAAP,KAAe,QADD,KAEbD,GAAG,KAAKL,GAAG,CAACQ,UAAZ,IAA0BF,GAAG,KAAKN,GAAG,CAACS,UAFzB,CAAhB;AAIA,MAAMC,QAAQ,GAAGV,GAAG,CAACU,QAArB;AACA,MAAMC,MAAM,GAAGX,GAAG,CAACW,MAAnB;AACA,MAAMC,KAAK,GAAGZ,GAAG,CAACY,KAAlB;AACA,MAAMC,GAAG,GAAGb,GAAG,CAACa,GAAhB;;AAEA,MAAMC,IAAI,GAAG,SAAPA,IAAO,CAACE,OAAD,EAAa;AACxBJ,IAAAA,KAAK,CAACK,GAAN,CAAUlB,GAAV,EAAe,IAAf;AACA,QAAIiB,OAAO,IAAIT,OAAf,EACEhB,MAAM,CAACmD,IAAP,CAAY1B,OAAZ,EAAqBX,GAArB,EAA0BC,GAA1B;AACF,QAAIF,SAAJ,EACEf,EAAE,CAACsD,SAAH,CAAa5C,GAAb,EAAkBI,IAAlB;AACH,GAND;;AAQA,MAAIS,KAAK,IAAIA,KAAK,CAACO,GAAN,CAAUpB,GAAV,MAAmB,IAAhC,EACE,OAAOe,IAAI,EAAX;;AAEF,MAAIf,GAAG,KAAKc,GAAZ,EAAiB;AACf,QAAI+B,EAAE,GAAG,KAAT;AACA,QAAIhD,IAAI,GAAG,SAAX;;AACA,QAAI;AACFgD,MAAAA,EAAE,GAAGvD,EAAE,CAACwD,QAAH,CAAY9C,GAAZ,EAAiBuB,WAAjB,EAAL;AACD,KAFD,CAEE,OAAOP,EAAP,EAAW;AACXnB,MAAAA,IAAI,GAAGmB,EAAE,CAACnB,IAAV;AACD,KAJD,SAIU;AACR,UAAI,CAACgD,EAAL,EACE,MAAM,IAAIjD,QAAJ,CAAaI,GAAb,EAAkBH,IAAlB,CAAN;AACH;;AACDkB,IAAAA,IAAI;AACJ;AACD;;AAED,MAAIJ,QAAJ,EACE,OAAOI,IAAI,CAAC3B,MAAM,CAACuD,IAAP,CAAY3C,GAAZ,EAAiBI,IAAjB,CAAD,CAAX;AAEF,MAAMsB,GAAG,GAAGnC,IAAI,CAACoC,QAAL,CAAcb,GAAd,EAAmBd,GAAnB,CAAZ;AACA,MAAM4B,KAAK,GAAGF,GAAG,CAACG,KAAJ,CAAU,OAAV,CAAd;AACA,MAAIZ,OAAO,GAAG,IAAd;;AACA,OAAK,IAAIgB,CAAC,GAAGL,KAAK,CAACM,KAAN,EAAR,EAAuBC,IAAI,GAAGrB,GAAnC,EACEmB,CAAC,KAAKE,IAAI,IAAI,MAAMF,CAAnB,CADH,EAEEA,CAAC,GAAGL,KAAK,CAACM,KAAN,EAFN,EAEqB;AACnB,QAAIrB,KAAK,CAACO,GAAN,CAAUe,IAAV,CAAJ,EACE;;AAEF,QAAI;AACF7C,MAAAA,EAAE,CAACyD,SAAH,CAAaZ,IAAb,EAAmB/B,IAAnB;AACAa,MAAAA,OAAO,GAAGA,OAAO,IAAIkB,IAArB;AACAtB,MAAAA,KAAK,CAACK,GAAN,CAAUiB,IAAV,EAAgB,IAAhB;AACD,KAJD,CAIE,OAAOnB,EAAP,EAAW;AACX,UAAIA,EAAE,CAACzB,IAAH,IAAWA,IAAI,CAAC+C,OAAL,CAAatB,EAAE,CAACzB,IAAhB,MAA0BuB,GAArC,KACCE,EAAE,CAACnB,IAAH,KAAY,SAAZ,IAAyBmB,EAAE,CAACnB,IAAH,KAAY,QADtC,CAAJ,EAEE,OAAO,IAAID,QAAJ,CAAakB,GAAb,EAAkBE,EAAE,CAACnB,IAArB,CAAP;AAEF,UAAMyB,EAAE,GAAGhC,EAAE,CAAC0D,SAAH,CAAab,IAAb,CAAX;;AACA,UAAIb,EAAE,CAACC,WAAH,EAAJ,EAAsB;AACpBV,QAAAA,KAAK,CAACK,GAAN,CAAUiB,IAAV,EAAgB,IAAhB;AACA;AACD,OAHD,MAGO,IAAIvB,MAAJ,EAAY;AACjBtB,QAAAA,EAAE,CAAC2D,UAAH,CAAcd,IAAd;AACA7C,QAAAA,EAAE,CAACyD,SAAH,CAAaZ,IAAb,EAAmB/B,IAAnB;AACAa,QAAAA,OAAO,GAAGA,OAAO,IAAIkB,IAArB;AACAtB,QAAAA,KAAK,CAACK,GAAN,CAAUiB,IAAV,EAAgB,IAAhB;AACA;AACD,OANM,MAMA,IAAIb,EAAE,CAACmB,cAAH,EAAJ,EACL,OAAO,IAAIhD,YAAJ,CAAiB0C,IAAjB,EAAuBA,IAAI,GAAG,GAAP,GAAaP,KAAK,CAACc,IAAN,CAAW,GAAX,CAApC,CAAP;AACH;AACF;;AAED,SAAO3B,IAAI,CAACE,OAAD,CAAX;AACD,CAjFD","sourcesContent":["'use strict'\n// wrapper around mkdirp for tar's needs.\n\n// TODO: This should probably be a class, not functionally\n// passing around state in a gazillion args.\n\nconst mkdirp = require('mkdirp')\nconst fs = require('fs')\nconst path = require('path')\nconst chownr = require('chownr')\n\nclass SymlinkError extends Error {\n  constructor (symlink, path) {\n    super('Cannot extract through symbolic link')\n    this.path = path\n    this.symlink = symlink\n  }\n\n  get name () {\n    return 'SylinkError'\n  }\n}\n\nclass CwdError extends Error {\n  constructor (path, code) {\n    super(code + ': Cannot cd into \\'' + path + '\\'')\n    this.path = path\n    this.code = code\n  }\n\n  get name () {\n    return 'CwdError'\n  }\n}\n\nmodule.exports = (dir, opt, cb) => {\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  const umask = opt.umask\n  const mode = opt.mode | 0o0700\n  const needChmod = (mode & umask) !== 0\n\n  const uid = opt.uid\n  const gid = opt.gid\n  const doChown = typeof uid === 'number' &&\n    typeof gid === 'number' &&\n    (uid !== opt.processUid || gid !== opt.processGid)\n\n  const preserve = opt.preserve\n  const unlink = opt.unlink\n  const cache = opt.cache\n  const cwd = opt.cwd\n\n  const done = (er, created) => {\n    if (er)\n      cb(er)\n    else {\n      cache.set(dir, true)\n      if (created && doChown)\n        chownr(created, uid, gid, er => done(er))\n      else if (needChmod)\n        fs.chmod(dir, mode, cb)\n      else\n        cb()\n    }\n  }\n\n  if (cache && cache.get(dir) === true)\n    return done()\n\n  if (dir === cwd) {\n    return fs.stat(dir, (er, st) => {\n      if (er || !st.isDirectory())\n        er = new CwdError(dir, er && er.code || 'ENOTDIR')\n      done(er)\n    })\n  }\n\n  if (preserve)\n    return mkdirp(dir, {mode}).then(made => done(null, made), done)\n\n  const sub = path.relative(cwd, dir)\n  const parts = sub.split(/\\/|\\\\/)\n  mkdir_(cwd, parts, mode, cache, unlink, cwd, null, done)\n}\n\nconst mkdir_ = (base, parts, mode, cache, unlink, cwd, created, cb) => {\n  if (!parts.length)\n    return cb(null, created)\n  const p = parts.shift()\n  const part = base + '/' + p\n  if (cache.get(part))\n    return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n  fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))\n}\n\nconst onmkdir = (part, parts, mode, cache, unlink, cwd, created, cb) => er => {\n  if (er) {\n    if (er.path && path.dirname(er.path) === cwd &&\n        (er.code === 'ENOTDIR' || er.code === 'ENOENT'))\n      return cb(new CwdError(cwd, er.code))\n\n    fs.lstat(part, (statEr, st) => {\n      if (statEr)\n        cb(statEr)\n      else if (st.isDirectory())\n        mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n      else if (unlink) {\n        fs.unlink(part, er => {\n          if (er)\n            return cb(er)\n          fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))\n        })\n      } else if (st.isSymbolicLink())\n        return cb(new SymlinkError(part, part + '/' + parts.join('/')))\n      else\n        cb(er)\n    })\n  } else {\n    created = created || part\n    mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n  }\n}\n\nmodule.exports.sync = (dir, opt) => {\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  const umask = opt.umask\n  const mode = opt.mode | 0o0700\n  const needChmod = (mode & umask) !== 0\n\n  const uid = opt.uid\n  const gid = opt.gid\n  const doChown = typeof uid === 'number' &&\n    typeof gid === 'number' &&\n    (uid !== opt.processUid || gid !== opt.processGid)\n\n  const preserve = opt.preserve\n  const unlink = opt.unlink\n  const cache = opt.cache\n  const cwd = opt.cwd\n\n  const done = (created) => {\n    cache.set(dir, true)\n    if (created && doChown)\n      chownr.sync(created, uid, gid)\n    if (needChmod)\n      fs.chmodSync(dir, mode)\n  }\n\n  if (cache && cache.get(dir) === true)\n    return done()\n\n  if (dir === cwd) {\n    let ok = false\n    let code = 'ENOTDIR'\n    try {\n      ok = fs.statSync(dir).isDirectory()\n    } catch (er) {\n      code = er.code\n    } finally {\n      if (!ok)\n        throw new CwdError(dir, code)\n    }\n    done()\n    return\n  }\n\n  if (preserve)\n    return done(mkdirp.sync(dir, mode))\n\n  const sub = path.relative(cwd, dir)\n  const parts = sub.split(/\\/|\\\\/)\n  let created = null\n  for (let p = parts.shift(), part = cwd;\n    p && (part += '/' + p);\n    p = parts.shift()) {\n    if (cache.get(part))\n      continue\n\n    try {\n      fs.mkdirSync(part, mode)\n      created = created || part\n      cache.set(part, true)\n    } catch (er) {\n      if (er.path && path.dirname(er.path) === cwd &&\n          (er.code === 'ENOTDIR' || er.code === 'ENOENT'))\n        return new CwdError(cwd, er.code)\n\n      const st = fs.lstatSync(part)\n      if (st.isDirectory()) {\n        cache.set(part, true)\n        continue\n      } else if (unlink) {\n        fs.unlinkSync(part)\n        fs.mkdirSync(part, mode)\n        created = created || part\n        cache.set(part, true)\n        continue\n      } else if (st.isSymbolicLink())\n        return new SymlinkError(part, part + '/' + parts.join('/'))\n    }\n  }\n\n  return done(created)\n}\n"]},"metadata":{},"sourceType":"script"}