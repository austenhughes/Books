{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar EE = require('events');\n\nvar Stream = require('stream');\n\nvar Yallist = require('yallist');\n\nvar SD = require('string_decoder').StringDecoder;\n\nvar EOF = Symbol('EOF');\nvar MAYBE_EMIT_END = Symbol('maybeEmitEnd');\nvar EMITTED_END = Symbol('emittedEnd');\nvar EMITTING_END = Symbol('emittingEnd');\nvar CLOSED = Symbol('closed');\nvar READ = Symbol('read');\nvar FLUSH = Symbol('flush');\nvar FLUSHCHUNK = Symbol('flushChunk');\nvar ENCODING = Symbol('encoding');\nvar DECODER = Symbol('decoder');\nvar FLOWING = Symbol('flowing');\nvar PAUSED = Symbol('paused');\nvar RESUME = Symbol('resume');\nvar BUFFERLENGTH = Symbol('bufferLength');\nvar BUFFERPUSH = Symbol('bufferPush');\nvar BUFFERSHIFT = Symbol('bufferShift');\nvar OBJECTMODE = Symbol('objectMode');\nvar DESTROYED = Symbol('destroyed'); // TODO remove when Node v8 support drops\n\nvar doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== '1';\nvar ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol('asyncIterator not implemented');\nvar ITERATOR = doIter && Symbol.iterator || Symbol('iterator not implemented'); // events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\n\nvar isEndish = function isEndish(ev) {\n  return ev === 'end' || ev === 'finish' || ev === 'prefinish';\n};\n\nvar isArrayBuffer = function isArrayBuffer(b) {\n  return b instanceof ArrayBuffer || typeof b === 'object' && b.constructor && b.constructor.name === 'ArrayBuffer' && b.byteLength >= 0;\n};\n\nvar isArrayBufferView = function isArrayBufferView(b) {\n  return !Buffer.isBuffer(b) && ArrayBuffer.isView(b);\n};\n\nmodule.exports = /*#__PURE__*/function (_Stream) {\n  _inherits(Minipass, _Stream);\n\n  var _super = _createSuper(Minipass);\n\n  function Minipass(options) {\n    var _this;\n\n    _classCallCheck(this, Minipass);\n\n    _this = _super.call(this);\n    _this[FLOWING] = false; // whether we're explicitly paused\n\n    _this[PAUSED] = false;\n    _this.pipes = new Yallist();\n    _this.buffer = new Yallist();\n    _this[OBJECTMODE] = options && options.objectMode || false;\n    if (_this[OBJECTMODE]) _this[ENCODING] = null;else _this[ENCODING] = options && options.encoding || null;\n    if (_this[ENCODING] === 'buffer') _this[ENCODING] = null;\n    _this[DECODER] = _this[ENCODING] ? new SD(_this[ENCODING]) : null;\n    _this[EOF] = false;\n    _this[EMITTED_END] = false;\n    _this[EMITTING_END] = false;\n    _this[CLOSED] = false;\n    _this.writable = true;\n    _this.readable = true;\n    _this[BUFFERLENGTH] = 0;\n    _this[DESTROYED] = false;\n    return _this;\n  }\n\n  _createClass(Minipass, [{\n    key: \"bufferLength\",\n    get: function get() {\n      return this[BUFFERLENGTH];\n    }\n  }, {\n    key: \"encoding\",\n    get: function get() {\n      return this[ENCODING];\n    },\n    set: function set(enc) {\n      var _this2 = this;\n\n      if (this[OBJECTMODE]) throw new Error('cannot set encoding in objectMode');\n      if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH])) throw new Error('cannot change encoding');\n\n      if (this[ENCODING] !== enc) {\n        this[DECODER] = enc ? new SD(enc) : null;\n        if (this.buffer.length) this.buffer = this.buffer.map(function (chunk) {\n          return _this2[DECODER].write(chunk);\n        });\n      }\n\n      this[ENCODING] = enc;\n    }\n  }, {\n    key: \"setEncoding\",\n    value: function setEncoding(enc) {\n      this.encoding = enc;\n    }\n  }, {\n    key: \"objectMode\",\n    get: function get() {\n      return this[OBJECTMODE];\n    },\n    set: function set(om) {\n      this[OBJECTMODE] = this[OBJECTMODE] || !!om;\n    }\n  }, {\n    key: \"write\",\n    value: function write(chunk, encoding, cb) {\n      if (this[EOF]) throw new Error('write after end');\n\n      if (this[DESTROYED]) {\n        this.emit('error', Object.assign(new Error('Cannot call write after a stream was destroyed'), {\n          code: 'ERR_STREAM_DESTROYED'\n        }));\n        return true;\n      }\n\n      if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n      if (!encoding) encoding = 'utf8'; // convert array buffers and typed array views into buffers\n      // at some point in the future, we may want to do the opposite!\n      // leave strings and buffers as-is\n      // anything else switches us into object mode\n\n      if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n        if (isArrayBufferView(chunk)) chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);else if (isArrayBuffer(chunk)) chunk = Buffer.from(chunk);else if (typeof chunk !== 'string') // use the setter so we throw if we have encoding set\n          this.objectMode = true;\n      } // this ensures at this point that the chunk is a buffer or string\n      // don't buffer it up or send it to the decoder\n\n\n      if (!this.objectMode && !chunk.length) {\n        if (this[BUFFERLENGTH] !== 0) this.emit('readable');\n        if (cb) cb();\n        return this.flowing;\n      } // fast-path writing strings of same encoding to a stream with\n      // an empty buffer, skipping the buffer/decoder dance\n\n\n      if (typeof chunk === 'string' && !this[OBJECTMODE] && // unless it is a string already ready for us to use\n      !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {\n        chunk = Buffer.from(chunk, encoding);\n      }\n\n      if (Buffer.isBuffer(chunk) && this[ENCODING]) chunk = this[DECODER].write(chunk);\n\n      if (this.flowing) {\n        // if we somehow have something in the buffer, but we think we're\n        // flowing, then we need to flush all that out first, or we get\n        // chunks coming in out of order.  Can't emit 'drain' here though,\n        // because we're mid-write, so that'd be bad.\n        if (this[BUFFERLENGTH] !== 0) this[FLUSH](true);\n        this.emit('data', chunk);\n      } else this[BUFFERPUSH](chunk);\n\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable');\n      if (cb) cb();\n      return this.flowing;\n    }\n  }, {\n    key: \"read\",\n    value: function read(n) {\n      if (this[DESTROYED]) return null;\n\n      try {\n        if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) return null;\n        if (this[OBJECTMODE]) n = null;\n\n        if (this.buffer.length > 1 && !this[OBJECTMODE]) {\n          if (this.encoding) this.buffer = new Yallist([Array.from(this.buffer).join('')]);else this.buffer = new Yallist([Buffer.concat(Array.from(this.buffer), this[BUFFERLENGTH])]);\n        }\n\n        return this[READ](n || null, this.buffer.head.value);\n      } finally {\n        this[MAYBE_EMIT_END]();\n      }\n    }\n  }, {\n    key: READ,\n    value: function value(n, chunk) {\n      if (n === chunk.length || n === null) this[BUFFERSHIFT]();else {\n        this.buffer.head.value = chunk.slice(n);\n        chunk = chunk.slice(0, n);\n        this[BUFFERLENGTH] -= n;\n      }\n      this.emit('data', chunk);\n      if (!this.buffer.length && !this[EOF]) this.emit('drain');\n      return chunk;\n    }\n  }, {\n    key: \"end\",\n    value: function end(chunk, encoding, cb) {\n      if (typeof chunk === 'function') cb = chunk, chunk = null;\n      if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n      if (chunk) this.write(chunk, encoding);\n      if (cb) this.once('end', cb);\n      this[EOF] = true;\n      this.writable = false; // if we haven't written anything, then go ahead and emit,\n      // even if we're not reading.\n      // we'll re-emit if a new 'end' listener is added anyway.\n      // This makes MP more suitable to write-only use cases.\n\n      if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]();\n      return this;\n    } // don't let the internal resume be overwritten\n\n  }, {\n    key: RESUME,\n    value: function value() {\n      if (this[DESTROYED]) return;\n      this[PAUSED] = false;\n      this[FLOWING] = true;\n      this.emit('resume');\n      if (this.buffer.length) this[FLUSH]();else if (this[EOF]) this[MAYBE_EMIT_END]();else this.emit('drain');\n    }\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      return this[RESUME]();\n    }\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      this[FLOWING] = false;\n      this[PAUSED] = true;\n    }\n  }, {\n    key: \"destroyed\",\n    get: function get() {\n      return this[DESTROYED];\n    }\n  }, {\n    key: \"flowing\",\n    get: function get() {\n      return this[FLOWING];\n    }\n  }, {\n    key: \"paused\",\n    get: function get() {\n      return this[PAUSED];\n    }\n  }, {\n    key: BUFFERPUSH,\n    value: function value(chunk) {\n      if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;else this[BUFFERLENGTH] += chunk.length;\n      return this.buffer.push(chunk);\n    }\n  }, {\n    key: BUFFERSHIFT,\n    value: function value() {\n      if (this.buffer.length) {\n        if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;else this[BUFFERLENGTH] -= this.buffer.head.value.length;\n      }\n\n      return this.buffer.shift();\n    }\n  }, {\n    key: FLUSH,\n    value: function value(noDrain) {\n      do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));\n\n      if (!noDrain && !this.buffer.length && !this[EOF]) this.emit('drain');\n    }\n  }, {\n    key: FLUSHCHUNK,\n    value: function value(chunk) {\n      return chunk ? (this.emit('data', chunk), this.flowing) : false;\n    }\n  }, {\n    key: \"pipe\",\n    value: function pipe(dest, opts) {\n      var _this3 = this;\n\n      if (this[DESTROYED]) return;\n      var ended = this[EMITTED_END];\n      opts = opts || {};\n      if (dest === process.stdout || dest === process.stderr) opts.end = false;else opts.end = opts.end !== false;\n      var p = {\n        dest: dest,\n        opts: opts,\n        ondrain: function ondrain(_) {\n          return _this3[RESUME]();\n        }\n      };\n      this.pipes.push(p);\n      dest.on('drain', p.ondrain);\n      this[RESUME](); // piping an ended stream ends immediately\n\n      if (ended && p.opts.end) p.dest.end();\n      return dest;\n    }\n  }, {\n    key: \"addListener\",\n    value: function addListener(ev, fn) {\n      return this.on(ev, fn);\n    }\n  }, {\n    key: \"on\",\n    value: function on(ev, fn) {\n      try {\n        return _get(_getPrototypeOf(Minipass.prototype), \"on\", this).call(this, ev, fn);\n      } finally {\n        if (ev === 'data' && !this.pipes.length && !this.flowing) this[RESUME]();else if (isEndish(ev) && this[EMITTED_END]) {\n          _get(_getPrototypeOf(Minipass.prototype), \"emit\", this).call(this, ev);\n\n          this.removeAllListeners(ev);\n        }\n      }\n    }\n  }, {\n    key: \"emittedEnd\",\n    get: function get() {\n      return this[EMITTED_END];\n    }\n  }, {\n    key: MAYBE_EMIT_END,\n    value: function value() {\n      if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this.buffer.length === 0 && this[EOF]) {\n        this[EMITTING_END] = true;\n        this.emit('end');\n        this.emit('prefinish');\n        this.emit('finish');\n        if (this[CLOSED]) this.emit('close');\n        this[EMITTING_END] = false;\n      }\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(ev, data) {\n      var _this4 = this;\n\n      // error and close are only events allowed after calling destroy()\n      if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED]) return;else if (ev === 'data') {\n        if (!data) return;\n        if (this.pipes.length) this.pipes.forEach(function (p) {\n          return p.dest.write(data) === false && _this4.pause();\n        });\n      } else if (ev === 'end') {\n        // only actual end gets this treatment\n        if (this[EMITTED_END] === true) return;\n        this[EMITTED_END] = true;\n        this.readable = false;\n\n        if (this[DECODER]) {\n          data = this[DECODER].end();\n\n          if (data) {\n            this.pipes.forEach(function (p) {\n              return p.dest.write(data);\n            });\n\n            _get(_getPrototypeOf(Minipass.prototype), \"emit\", this).call(this, 'data', data);\n          }\n        }\n\n        this.pipes.forEach(function (p) {\n          p.dest.removeListener('drain', p.ondrain);\n          if (p.opts.end) p.dest.end();\n        });\n      } else if (ev === 'close') {\n        this[CLOSED] = true; // don't emit close before 'end' and 'finish'\n\n        if (!this[EMITTED_END] && !this[DESTROYED]) return;\n      } // TODO: replace with a spread operator when Node v4 support drops\n\n      var args = new Array(arguments.length);\n      args[0] = ev;\n      args[1] = data;\n\n      if (arguments.length > 2) {\n        for (var i = 2; i < arguments.length; i++) {\n          args[i] = arguments[i];\n        }\n      }\n\n      try {\n        return _get(_getPrototypeOf(Minipass.prototype), \"emit\", this).apply(this, args);\n      } finally {\n        if (!isEndish(ev)) this[MAYBE_EMIT_END]();else this.removeAllListeners(ev);\n      }\n    } // const all = await stream.collect()\n\n  }, {\n    key: \"collect\",\n    value: function collect() {\n      var _this5 = this;\n\n      var buf = [];\n      if (!this[OBJECTMODE]) buf.dataLength = 0; // set the promise first, in case an error is raised\n      // by triggering the flow here.\n\n      var p = this.promise();\n      this.on('data', function (c) {\n        buf.push(c);\n        if (!_this5[OBJECTMODE]) buf.dataLength += c.length;\n      });\n      return p.then(function () {\n        return buf;\n      });\n    } // const data = await stream.concat()\n\n  }, {\n    key: \"concat\",\n    value: function concat() {\n      var _this6 = this;\n\n      return this[OBJECTMODE] ? Promise.reject(new Error('cannot concat in objectMode')) : this.collect().then(function (buf) {\n        return _this6[OBJECTMODE] ? Promise.reject(new Error('cannot concat in objectMode')) : _this6[ENCODING] ? buf.join('') : Buffer.concat(buf, buf.dataLength);\n      });\n    } // stream.promise().then(() => done, er => emitted error)\n\n  }, {\n    key: \"promise\",\n    value: function promise() {\n      var _this7 = this;\n\n      return new Promise(function (resolve, reject) {\n        _this7.on(DESTROYED, function () {\n          return reject(new Error('stream destroyed'));\n        });\n\n        _this7.on('end', function () {\n          return resolve();\n        });\n\n        _this7.on('error', function (er) {\n          return reject(er);\n        });\n      });\n    } // for await (let chunk of stream)\n\n  }, {\n    key: ASYNCITERATOR,\n    value: function value() {\n      var _this8 = this;\n\n      var next = function next() {\n        var res = _this8.read();\n\n        if (res !== null) return Promise.resolve({\n          done: false,\n          value: res\n        });\n        if (_this8[EOF]) return Promise.resolve({\n          done: true\n        });\n        var resolve = null;\n        var reject = null;\n\n        var onerr = function onerr(er) {\n          _this8.removeListener('data', ondata);\n\n          _this8.removeListener('end', onend);\n\n          reject(er);\n        };\n\n        var ondata = function ondata(value) {\n          _this8.removeListener('error', onerr);\n\n          _this8.removeListener('end', onend);\n\n          _this8.pause();\n\n          resolve({\n            value: value,\n            done: !!_this8[EOF]\n          });\n        };\n\n        var onend = function onend() {\n          _this8.removeListener('error', onerr);\n\n          _this8.removeListener('data', ondata);\n\n          resolve({\n            done: true\n          });\n        };\n\n        var ondestroy = function ondestroy() {\n          return onerr(new Error('stream destroyed'));\n        };\n\n        return new Promise(function (res, rej) {\n          reject = rej;\n          resolve = res;\n\n          _this8.once(DESTROYED, ondestroy);\n\n          _this8.once('error', onerr);\n\n          _this8.once('end', onend);\n\n          _this8.once('data', ondata);\n        });\n      };\n\n      return {\n        next: next\n      };\n    } // for (let chunk of stream)\n\n  }, {\n    key: ITERATOR,\n    value: function value() {\n      var _this9 = this;\n\n      var next = function next() {\n        var value = _this9.read();\n\n        var done = value === null;\n        return {\n          value: value,\n          done: done\n        };\n      };\n\n      return {\n        next: next\n      };\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy(er) {\n      if (this[DESTROYED]) {\n        if (er) this.emit('error', er);else this.emit(DESTROYED);\n        return this;\n      }\n\n      this[DESTROYED] = true; // throw away all buffered data, it's never coming out\n\n      this.buffer = new Yallist();\n      this[BUFFERLENGTH] = 0;\n      if (typeof this.close === 'function' && !this[CLOSED]) this.close();\n      if (er) this.emit('error', er);else // if no error to emit, still reject pending promises\n        this.emit(DESTROYED);\n      return this;\n    }\n  }], [{\n    key: \"isStream\",\n    value: function isStream(s) {\n      return !!s && (s instanceof Minipass || s instanceof Stream || s instanceof EE && (typeof s.pipe === 'function' || // readable\n      typeof s.write === 'function' && typeof s.end === 'function' // writable\n      ));\n    }\n  }]);\n\n  return Minipass;\n}(Stream);","map":{"version":3,"sources":["/Users/austenhughes/The-Baffoonery/node_modules/minipass/index.js"],"names":["EE","require","Stream","Yallist","SD","StringDecoder","EOF","Symbol","MAYBE_EMIT_END","EMITTED_END","EMITTING_END","CLOSED","READ","FLUSH","FLUSHCHUNK","ENCODING","DECODER","FLOWING","PAUSED","RESUME","BUFFERLENGTH","BUFFERPUSH","BUFFERSHIFT","OBJECTMODE","DESTROYED","doIter","global","_MP_NO_ITERATOR_SYMBOLS_","ASYNCITERATOR","asyncIterator","ITERATOR","iterator","isEndish","ev","isArrayBuffer","b","ArrayBuffer","constructor","name","byteLength","isArrayBufferView","Buffer","isBuffer","isView","module","exports","options","pipes","buffer","objectMode","encoding","writable","readable","enc","Error","lastNeed","length","map","chunk","write","om","cb","emit","Object","assign","code","from","byteOffset","flowing","n","Array","join","concat","head","value","slice","once","push","shift","noDrain","dest","opts","ended","process","stdout","stderr","end","p","ondrain","_","on","fn","removeAllListeners","data","forEach","pause","removeListener","args","arguments","i","apply","buf","dataLength","promise","c","then","Promise","reject","collect","resolve","er","next","res","read","done","onerr","ondata","onend","ondestroy","rej","close","s","Minipass","pipe"],"mappings":"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","sourcesContent":["'use strict'\nconst EE = require('events')\nconst Stream = require('stream')\nconst Yallist = require('yallist')\nconst SD = require('string_decoder').StringDecoder\n\nconst EOF = Symbol('EOF')\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd')\nconst EMITTED_END = Symbol('emittedEnd')\nconst EMITTING_END = Symbol('emittingEnd')\nconst CLOSED = Symbol('closed')\nconst READ = Symbol('read')\nconst FLUSH = Symbol('flush')\nconst FLUSHCHUNK = Symbol('flushChunk')\nconst ENCODING = Symbol('encoding')\nconst DECODER = Symbol('decoder')\nconst FLOWING = Symbol('flowing')\nconst PAUSED = Symbol('paused')\nconst RESUME = Symbol('resume')\nconst BUFFERLENGTH = Symbol('bufferLength')\nconst BUFFERPUSH = Symbol('bufferPush')\nconst BUFFERSHIFT = Symbol('bufferShift')\nconst OBJECTMODE = Symbol('objectMode')\nconst DESTROYED = Symbol('destroyed')\n\n// TODO remove when Node v8 support drops\nconst doIter = global._MP_NO_ITERATOR_SYMBOLS_  !== '1'\nconst ASYNCITERATOR = doIter && Symbol.asyncIterator\n  || Symbol('asyncIterator not implemented')\nconst ITERATOR = doIter && Symbol.iterator\n  || Symbol('iterator not implemented')\n\n// events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\nconst isEndish = ev =>\n  ev === 'end' ||\n  ev === 'finish' ||\n  ev === 'prefinish'\n\nconst isArrayBuffer = b => b instanceof ArrayBuffer ||\n  typeof b === 'object' &&\n  b.constructor &&\n  b.constructor.name === 'ArrayBuffer' &&\n  b.byteLength >= 0\n\nconst isArrayBufferView = b => !Buffer.isBuffer(b) && ArrayBuffer.isView(b)\n\nmodule.exports = class Minipass extends Stream {\n  constructor (options) {\n    super()\n    this[FLOWING] = false\n    // whether we're explicitly paused\n    this[PAUSED] = false\n    this.pipes = new Yallist()\n    this.buffer = new Yallist()\n    this[OBJECTMODE] = options && options.objectMode || false\n    if (this[OBJECTMODE])\n      this[ENCODING] = null\n    else\n      this[ENCODING] = options && options.encoding || null\n    if (this[ENCODING] === 'buffer')\n      this[ENCODING] = null\n    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null\n    this[EOF] = false\n    this[EMITTED_END] = false\n    this[EMITTING_END] = false\n    this[CLOSED] = false\n    this.writable = true\n    this.readable = true\n    this[BUFFERLENGTH] = 0\n    this[DESTROYED] = false\n  }\n\n  get bufferLength () { return this[BUFFERLENGTH] }\n\n  get encoding () { return this[ENCODING] }\n  set encoding (enc) {\n    if (this[OBJECTMODE])\n      throw new Error('cannot set encoding in objectMode')\n\n    if (this[ENCODING] && enc !== this[ENCODING] &&\n        (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))\n      throw new Error('cannot change encoding')\n\n    if (this[ENCODING] !== enc) {\n      this[DECODER] = enc ? new SD(enc) : null\n      if (this.buffer.length)\n        this.buffer = this.buffer.map(chunk => this[DECODER].write(chunk))\n    }\n\n    this[ENCODING] = enc\n  }\n\n  setEncoding (enc) {\n    this.encoding = enc\n  }\n\n  get objectMode () { return this[OBJECTMODE] }\n  set objectMode (om) { this[OBJECTMODE] = this[OBJECTMODE] || !!om }\n\n  write (chunk, encoding, cb) {\n    if (this[EOF])\n      throw new Error('write after end')\n\n    if (this[DESTROYED]) {\n      this.emit('error', Object.assign(\n        new Error('Cannot call write after a stream was destroyed'),\n        { code: 'ERR_STREAM_DESTROYED' }\n      ))\n      return true\n    }\n\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n\n    if (!encoding)\n      encoding = 'utf8'\n\n    // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything else switches us into object mode\n    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk))\n        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)\n      else if (isArrayBuffer(chunk))\n        chunk = Buffer.from(chunk)\n      else if (typeof chunk !== 'string')\n        // use the setter so we throw if we have encoding set\n        this.objectMode = true\n    }\n\n    // this ensures at this point that the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n    if (!this.objectMode && !chunk.length) {\n      if (this[BUFFERLENGTH] !== 0)\n        this.emit('readable')\n      if (cb)\n        cb()\n      return this.flowing\n    }\n\n    // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n    if (typeof chunk === 'string' && !this[OBJECTMODE] &&\n        // unless it is a string already ready for us to use\n        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {\n      chunk = Buffer.from(chunk, encoding)\n    }\n\n    if (Buffer.isBuffer(chunk) && this[ENCODING])\n      chunk = this[DECODER].write(chunk)\n\n    if (this.flowing) {\n      // if we somehow have something in the buffer, but we think we're\n      // flowing, then we need to flush all that out first, or we get\n      // chunks coming in out of order.  Can't emit 'drain' here though,\n      // because we're mid-write, so that'd be bad.\n      if (this[BUFFERLENGTH] !== 0)\n        this[FLUSH](true)\n      this.emit('data', chunk)\n    } else\n      this[BUFFERPUSH](chunk)\n\n    if (this[BUFFERLENGTH] !== 0)\n      this.emit('readable')\n\n    if (cb)\n      cb()\n\n    return this.flowing\n  }\n\n  read (n) {\n    if (this[DESTROYED])\n      return null\n\n    try {\n      if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH])\n        return null\n\n      if (this[OBJECTMODE])\n        n = null\n\n      if (this.buffer.length > 1 && !this[OBJECTMODE]) {\n        if (this.encoding)\n          this.buffer = new Yallist([\n            Array.from(this.buffer).join('')\n          ])\n        else\n          this.buffer = new Yallist([\n            Buffer.concat(Array.from(this.buffer), this[BUFFERLENGTH])\n          ])\n      }\n\n      return this[READ](n || null, this.buffer.head.value)\n    } finally {\n      this[MAYBE_EMIT_END]()\n    }\n  }\n\n  [READ] (n, chunk) {\n    if (n === chunk.length || n === null)\n      this[BUFFERSHIFT]()\n    else {\n      this.buffer.head.value = chunk.slice(n)\n      chunk = chunk.slice(0, n)\n      this[BUFFERLENGTH] -= n\n    }\n\n    this.emit('data', chunk)\n\n    if (!this.buffer.length && !this[EOF])\n      this.emit('drain')\n\n    return chunk\n  }\n\n  end (chunk, encoding, cb) {\n    if (typeof chunk === 'function')\n      cb = chunk, chunk = null\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n    if (chunk)\n      this.write(chunk, encoding)\n    if (cb)\n      this.once('end', cb)\n    this[EOF] = true\n    this.writable = false\n\n    // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n    if (this.flowing || !this[PAUSED])\n      this[MAYBE_EMIT_END]()\n    return this\n  }\n\n  // don't let the internal resume be overwritten\n  [RESUME] () {\n    if (this[DESTROYED])\n      return\n\n    this[PAUSED] = false\n    this[FLOWING] = true\n    this.emit('resume')\n    if (this.buffer.length)\n      this[FLUSH]()\n    else if (this[EOF])\n      this[MAYBE_EMIT_END]()\n    else\n      this.emit('drain')\n  }\n\n  resume () {\n    return this[RESUME]()\n  }\n\n  pause () {\n    this[FLOWING] = false\n    this[PAUSED] = true\n  }\n\n  get destroyed () {\n    return this[DESTROYED]\n  }\n\n  get flowing () {\n    return this[FLOWING]\n  }\n\n  get paused () {\n    return this[PAUSED]\n  }\n\n  [BUFFERPUSH] (chunk) {\n    if (this[OBJECTMODE])\n      this[BUFFERLENGTH] += 1\n    else\n      this[BUFFERLENGTH] += chunk.length\n    return this.buffer.push(chunk)\n  }\n\n  [BUFFERSHIFT] () {\n    if (this.buffer.length) {\n      if (this[OBJECTMODE])\n        this[BUFFERLENGTH] -= 1\n      else\n        this[BUFFERLENGTH] -= this.buffer.head.value.length\n    }\n    return this.buffer.shift()\n  }\n\n  [FLUSH] (noDrain) {\n    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()))\n\n    if (!noDrain && !this.buffer.length && !this[EOF])\n      this.emit('drain')\n  }\n\n  [FLUSHCHUNK] (chunk) {\n    return chunk ? (this.emit('data', chunk), this.flowing) : false\n  }\n\n  pipe (dest, opts) {\n    if (this[DESTROYED])\n      return\n\n    const ended = this[EMITTED_END]\n    opts = opts || {}\n    if (dest === process.stdout || dest === process.stderr)\n      opts.end = false\n    else\n      opts.end = opts.end !== false\n\n    const p = { dest: dest, opts: opts, ondrain: _ => this[RESUME]() }\n    this.pipes.push(p)\n\n    dest.on('drain', p.ondrain)\n    this[RESUME]()\n    // piping an ended stream ends immediately\n    if (ended && p.opts.end)\n      p.dest.end()\n    return dest\n  }\n\n  addListener (ev, fn) {\n    return this.on(ev, fn)\n  }\n\n  on (ev, fn) {\n    try {\n      return super.on(ev, fn)\n    } finally {\n      if (ev === 'data' && !this.pipes.length && !this.flowing)\n        this[RESUME]()\n      else if (isEndish(ev) && this[EMITTED_END]) {\n        super.emit(ev)\n        this.removeAllListeners(ev)\n      }\n    }\n  }\n\n  get emittedEnd () {\n    return this[EMITTED_END]\n  }\n\n  [MAYBE_EMIT_END] () {\n    if (!this[EMITTING_END] &&\n        !this[EMITTED_END] &&\n        !this[DESTROYED] &&\n        this.buffer.length === 0 &&\n        this[EOF]) {\n      this[EMITTING_END] = true\n      this.emit('end')\n      this.emit('prefinish')\n      this.emit('finish')\n      if (this[CLOSED])\n        this.emit('close')\n      this[EMITTING_END] = false\n    }\n  }\n\n  emit (ev, data) {\n    // error and close are only events allowed after calling destroy()\n    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED])\n      return\n    else if (ev === 'data') {\n      if (!data)\n        return\n\n      if (this.pipes.length)\n        this.pipes.forEach(p =>\n          p.dest.write(data) === false && this.pause())\n    } else if (ev === 'end') {\n      // only actual end gets this treatment\n      if (this[EMITTED_END] === true)\n        return\n\n      this[EMITTED_END] = true\n      this.readable = false\n\n      if (this[DECODER]) {\n        data = this[DECODER].end()\n        if (data) {\n          this.pipes.forEach(p => p.dest.write(data))\n          super.emit('data', data)\n        }\n      }\n\n      this.pipes.forEach(p => {\n        p.dest.removeListener('drain', p.ondrain)\n        if (p.opts.end)\n          p.dest.end()\n      })\n    } else if (ev === 'close') {\n      this[CLOSED] = true\n      // don't emit close before 'end' and 'finish'\n      if (!this[EMITTED_END] && !this[DESTROYED])\n        return\n    }\n\n    // TODO: replace with a spread operator when Node v4 support drops\n    const args = new Array(arguments.length)\n    args[0] = ev\n    args[1] = data\n    if (arguments.length > 2) {\n      for (let i = 2; i < arguments.length; i++) {\n        args[i] = arguments[i]\n      }\n    }\n\n    try {\n      return super.emit.apply(this, args)\n    } finally {\n      if (!isEndish(ev))\n        this[MAYBE_EMIT_END]()\n      else\n        this.removeAllListeners(ev)\n    }\n  }\n\n  // const all = await stream.collect()\n  collect () {\n    const buf = []\n    if (!this[OBJECTMODE])\n      buf.dataLength = 0\n    // set the promise first, in case an error is raised\n    // by triggering the flow here.\n    const p = this.promise()\n    this.on('data', c => {\n      buf.push(c)\n      if (!this[OBJECTMODE])\n        buf.dataLength += c.length\n    })\n    return p.then(() => buf)\n  }\n\n  // const data = await stream.concat()\n  concat () {\n    return this[OBJECTMODE]\n      ? Promise.reject(new Error('cannot concat in objectMode'))\n      : this.collect().then(buf =>\n          this[OBJECTMODE]\n            ? Promise.reject(new Error('cannot concat in objectMode'))\n            : this[ENCODING] ? buf.join('') : Buffer.concat(buf, buf.dataLength))\n  }\n\n  // stream.promise().then(() => done, er => emitted error)\n  promise () {\n    return new Promise((resolve, reject) => {\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')))\n      this.on('end', () => resolve())\n      this.on('error', er => reject(er))\n    })\n  }\n\n  // for await (let chunk of stream)\n  [ASYNCITERATOR] () {\n    const next = () => {\n      const res = this.read()\n      if (res !== null)\n        return Promise.resolve({ done: false, value: res })\n\n      if (this[EOF])\n        return Promise.resolve({ done: true })\n\n      let resolve = null\n      let reject = null\n      const onerr = er => {\n        this.removeListener('data', ondata)\n        this.removeListener('end', onend)\n        reject(er)\n      }\n      const ondata = value => {\n        this.removeListener('error', onerr)\n        this.removeListener('end', onend)\n        this.pause()\n        resolve({ value: value, done: !!this[EOF] })\n      }\n      const onend = () => {\n        this.removeListener('error', onerr)\n        this.removeListener('data', ondata)\n        resolve({ done: true })\n      }\n      const ondestroy = () => onerr(new Error('stream destroyed'))\n      return new Promise((res, rej) => {\n        reject = rej\n        resolve = res\n        this.once(DESTROYED, ondestroy)\n        this.once('error', onerr)\n        this.once('end', onend)\n        this.once('data', ondata)\n      })\n    }\n\n    return { next }\n  }\n\n  // for (let chunk of stream)\n  [ITERATOR] () {\n    const next = () => {\n      const value = this.read()\n      const done = value === null\n      return { value, done }\n    }\n    return { next }\n  }\n\n  destroy (er) {\n    if (this[DESTROYED]) {\n      if (er)\n        this.emit('error', er)\n      else\n        this.emit(DESTROYED)\n      return this\n    }\n\n    this[DESTROYED] = true\n\n    // throw away all buffered data, it's never coming out\n    this.buffer = new Yallist()\n    this[BUFFERLENGTH] = 0\n\n    if (typeof this.close === 'function' && !this[CLOSED])\n      this.close()\n\n    if (er)\n      this.emit('error', er)\n    else // if no error to emit, still reject pending promises\n      this.emit(DESTROYED)\n\n    return this\n  }\n\n  static isStream (s) {\n    return !!s && (s instanceof Minipass || s instanceof Stream ||\n      s instanceof EE && (\n        typeof s.pipe === 'function' || // readable\n        (typeof s.write === 'function' && typeof s.end === 'function') // writable\n      ))\n  }\n}\n"]},"metadata":{},"sourceType":"script"}