{"ast":null,"code":"'use strict'; // the PEND/UNPEND stuff tracks whether we're ready to emit end/close yet.\n// but the path reservations are required to avoid race conditions where\n// parallelized unpack ops may mess with one another, due to dependencies\n// (like a Link depending on its target) or destructive operations (like\n// clobbering an fs object to create one of a different type.)\n\nvar _classCallCheck = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/austenhughes/The-Baffoonery/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar assert = require('assert');\n\nvar Parser = require('./parse.js');\n\nvar fs = require('fs');\n\nvar fsm = require('fs-minipass');\n\nvar path = require('path');\n\nvar mkdir = require('./mkdir.js');\n\nvar wc = require('./winchars.js');\n\nvar pathReservations = require('./path-reservations.js');\n\nvar ONENTRY = Symbol('onEntry');\nvar CHECKFS = Symbol('checkFs');\nvar CHECKFS2 = Symbol('checkFs2');\nvar ISREUSABLE = Symbol('isReusable');\nvar MAKEFS = Symbol('makeFs');\nvar FILE = Symbol('file');\nvar DIRECTORY = Symbol('directory');\nvar LINK = Symbol('link');\nvar SYMLINK = Symbol('symlink');\nvar HARDLINK = Symbol('hardlink');\nvar UNSUPPORTED = Symbol('unsupported');\nvar CHECKPATH = Symbol('checkPath');\nvar MKDIR = Symbol('mkdir');\nvar ONERROR = Symbol('onError');\nvar PENDING = Symbol('pending');\nvar PEND = Symbol('pend');\nvar UNPEND = Symbol('unpend');\nvar ENDED = Symbol('ended');\nvar MAYBECLOSE = Symbol('maybeClose');\nvar SKIP = Symbol('skip');\nvar DOCHOWN = Symbol('doChown');\nvar UID = Symbol('uid');\nvar GID = Symbol('gid');\n\nvar crypto = require('crypto');\n\nvar getFlag = require('./get-write-flag.js');\n/* istanbul ignore next */\n\n\nvar neverCalled = function neverCalled() {\n  throw new Error('sync function called cb somehow?!?');\n}; // Unlinks on Windows are not atomic.\n//\n// This means that if you have a file entry, followed by another\n// file entry with an identical name, and you cannot re-use the file\n// (because it's a hardlink, or because unlink:true is set, or it's\n// Windows, which does not have useful nlink values), then the unlink\n// will be committed to the disk AFTER the new file has been written\n// over the old one, deleting the new file.\n//\n// To work around this, on Windows systems, we rename the file and then\n// delete the renamed file.  It's a sloppy kludge, but frankly, I do not\n// know of a better way to do this, given windows' non-atomic unlink\n// semantics.\n//\n// See: https://github.com/npm/node-tar/issues/183\n\n/* istanbul ignore next */\n\n\nvar unlinkFile = function unlinkFile(path, cb) {\n  if (process.platform !== 'win32') return fs.unlink(path, cb);\n  var name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex');\n  fs.rename(path, name, function (er) {\n    if (er) return cb(er);\n    fs.unlink(name, cb);\n  });\n};\n/* istanbul ignore next */\n\n\nvar unlinkFileSync = function unlinkFileSync(path) {\n  if (process.platform !== 'win32') return fs.unlinkSync(path);\n  var name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex');\n  fs.renameSync(path, name);\n  fs.unlinkSync(name);\n}; // this.gid, entry.gid, this.processUid\n\n\nvar uint32 = function uint32(a, b, c) {\n  return a === a >>> 0 ? a : b === b >>> 0 ? b : c;\n};\n\nvar Unpack = /*#__PURE__*/function (_Parser) {\n  _inherits(Unpack, _Parser);\n\n  var _super = _createSuper(Unpack);\n\n  function Unpack(opt) {\n    var _this;\n\n    _classCallCheck(this, Unpack);\n\n    if (!opt) opt = {};\n\n    opt.ondone = function (_) {\n      _this[ENDED] = true;\n\n      _this[MAYBECLOSE]();\n    };\n\n    _this = _super.call(this, opt);\n    _this.reservations = pathReservations();\n    _this.transform = typeof opt.transform === 'function' ? opt.transform : null;\n    _this.writable = true;\n    _this.readable = false;\n    _this[PENDING] = 0;\n    _this[ENDED] = false;\n    _this.dirCache = opt.dirCache || new Map();\n\n    if (typeof opt.uid === 'number' || typeof opt.gid === 'number') {\n      // need both or neither\n      if (typeof opt.uid !== 'number' || typeof opt.gid !== 'number') throw new TypeError('cannot set owner without number uid and gid');\n\n      if (opt.preserveOwner) {\n        throw new TypeError('cannot preserve owner in archive and also set owner explicitly');\n      }\n\n      _this.uid = opt.uid;\n      _this.gid = opt.gid;\n      _this.setOwner = true;\n    } else {\n      _this.uid = null;\n      _this.gid = null;\n      _this.setOwner = false;\n    } // default true for root\n\n\n    if (opt.preserveOwner === undefined && typeof opt.uid !== 'number') _this.preserveOwner = process.getuid && process.getuid() === 0;else _this.preserveOwner = !!opt.preserveOwner;\n    _this.processUid = (_this.preserveOwner || _this.setOwner) && process.getuid ? process.getuid() : null;\n    _this.processGid = (_this.preserveOwner || _this.setOwner) && process.getgid ? process.getgid() : null; // mostly just for testing, but useful in some cases.\n    // Forcibly trigger a chown on every entry, no matter what\n\n    _this.forceChown = opt.forceChown === true; // turn ><?| in filenames into 0xf000-higher encoded forms\n\n    _this.win32 = !!opt.win32 || process.platform === 'win32'; // do not unpack over files that are newer than what's in the archive\n\n    _this.newer = !!opt.newer; // do not unpack over ANY files\n\n    _this.keep = !!opt.keep; // do not set mtime/atime of extracted entries\n\n    _this.noMtime = !!opt.noMtime; // allow .., absolute path entries, and unpacking through symlinks\n    // without this, warn and skip .., relativize absolutes, and error\n    // on symlinks in extraction path\n\n    _this.preservePaths = !!opt.preservePaths; // unlink files and links before writing. This breaks existing hard\n    // links, and removes symlink directories rather than erroring\n\n    _this.unlink = !!opt.unlink;\n    _this.cwd = path.resolve(opt.cwd || process.cwd());\n    _this.strip = +opt.strip || 0; // if we're not chmodding, then we don't need the process umask\n\n    _this.processUmask = opt.noChmod ? 0 : process.umask();\n    _this.umask = typeof opt.umask === 'number' ? opt.umask : _this.processUmask; // default mode for dirs created as parents\n\n    _this.dmode = opt.dmode || 511 & ~_this.umask;\n    _this.fmode = opt.fmode || 438 & ~_this.umask;\n\n    _this.on('entry', function (entry) {\n      return _this[ONENTRY](entry);\n    });\n\n    return _this;\n  } // a bad or damaged archive is a warning for Parser, but an error\n  // when extracting.  Mark those errors as unrecoverable, because\n  // the Unpack contract cannot be met.\n\n\n  _createClass(Unpack, [{\n    key: \"warn\",\n    value: function warn(code, msg) {\n      var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (code === 'TAR_BAD_ARCHIVE' || code === 'TAR_ABORT') data.recoverable = false;\n      return _get(_getPrototypeOf(Unpack.prototype), \"warn\", this).call(this, code, msg, data);\n    }\n  }, {\n    key: MAYBECLOSE,\n    value: function value() {\n      if (this[ENDED] && this[PENDING] === 0) {\n        this.emit('prefinish');\n        this.emit('finish');\n        this.emit('end');\n        this.emit('close');\n      }\n    }\n  }, {\n    key: CHECKPATH,\n    value: function value(entry) {\n      if (this.strip) {\n        var parts = entry.path.split(/\\/|\\\\/);\n        if (parts.length < this.strip) return false;\n        entry.path = parts.slice(this.strip).join('/');\n\n        if (entry.type === 'Link') {\n          var linkparts = entry.linkpath.split(/\\/|\\\\/);\n          if (linkparts.length >= this.strip) entry.linkpath = linkparts.slice(this.strip).join('/');\n        }\n      }\n\n      if (!this.preservePaths) {\n        var p = entry.path;\n\n        if (p.match(/(^|\\/|\\\\)\\.\\.(\\\\|\\/|$)/)) {\n          this.warn('TAR_ENTRY_ERROR', \"path contains '..'\", {\n            entry: entry,\n            path: p\n          });\n          return false;\n        } // absolutes on posix are also absolutes on win32\n        // so we only need to test this one to get both\n\n\n        if (path.win32.isAbsolute(p)) {\n          var parsed = path.win32.parse(p);\n          entry.path = p.substr(parsed.root.length);\n          var r = parsed.root;\n          this.warn('TAR_ENTRY_INFO', \"stripping \".concat(r, \" from absolute path\"), {\n            entry: entry,\n            path: p\n          });\n        }\n      } // only encode : chars that aren't drive letter indicators\n\n\n      if (this.win32) {\n        var _parsed = path.win32.parse(entry.path);\n\n        entry.path = _parsed.root === '' ? wc.encode(entry.path) : _parsed.root + wc.encode(entry.path.substr(_parsed.root.length));\n      }\n\n      if (path.isAbsolute(entry.path)) entry.absolute = entry.path;else entry.absolute = path.resolve(this.cwd, entry.path);\n      return true;\n    }\n  }, {\n    key: ONENTRY,\n    value: function value(entry) {\n      if (!this[CHECKPATH](entry)) return entry.resume();\n      assert.equal(typeof entry.absolute, 'string');\n\n      switch (entry.type) {\n        case 'Directory':\n        case 'GNUDumpDir':\n          if (entry.mode) entry.mode = entry.mode | 448;\n\n        case 'File':\n        case 'OldFile':\n        case 'ContiguousFile':\n        case 'Link':\n        case 'SymbolicLink':\n          return this[CHECKFS](entry);\n\n        case 'CharacterDevice':\n        case 'BlockDevice':\n        case 'FIFO':\n        default:\n          return this[UNSUPPORTED](entry);\n      }\n    }\n  }, {\n    key: ONERROR,\n    value: function value(er, entry) {\n      // Cwd has to exist, or else nothing works. That's serious.\n      // Other errors are warnings, which raise the error in strict\n      // mode, but otherwise continue on.\n      if (er.name === 'CwdError') this.emit('error', er);else {\n        this.warn('TAR_ENTRY_ERROR', er, {\n          entry: entry\n        });\n        this[UNPEND]();\n        entry.resume();\n      }\n    }\n  }, {\n    key: MKDIR,\n    value: function value(dir, mode, cb) {\n      mkdir(dir, {\n        uid: this.uid,\n        gid: this.gid,\n        processUid: this.processUid,\n        processGid: this.processGid,\n        umask: this.processUmask,\n        preserve: this.preservePaths,\n        unlink: this.unlink,\n        cache: this.dirCache,\n        cwd: this.cwd,\n        mode: mode,\n        noChmod: this.noChmod\n      }, cb);\n    }\n  }, {\n    key: DOCHOWN,\n    value: function value(entry) {\n      // in preserve owner mode, chown if the entry doesn't match process\n      // in set owner mode, chown if setting doesn't match process\n      return this.forceChown || this.preserveOwner && (typeof entry.uid === 'number' && entry.uid !== this.processUid || typeof entry.gid === 'number' && entry.gid !== this.processGid) || typeof this.uid === 'number' && this.uid !== this.processUid || typeof this.gid === 'number' && this.gid !== this.processGid;\n    }\n  }, {\n    key: UID,\n    value: function value(entry) {\n      return uint32(this.uid, entry.uid, this.processUid);\n    }\n  }, {\n    key: GID,\n    value: function value(entry) {\n      return uint32(this.gid, entry.gid, this.processGid);\n    }\n  }, {\n    key: FILE,\n    value: function value(entry, fullyDone) {\n      var _this2 = this;\n\n      var mode = entry.mode & 4095 || this.fmode;\n      var stream = new fsm.WriteStream(entry.absolute, {\n        flags: getFlag(entry.size),\n        mode: mode,\n        autoClose: false\n      });\n      stream.on('error', function (er) {\n        return _this2[ONERROR](er, entry);\n      });\n      var actions = 1;\n\n      var done = function done(er) {\n        if (er) return _this2[ONERROR](er, entry);\n\n        if (--actions === 0) {\n          fs.close(stream.fd, function (er) {\n            fullyDone();\n            er ? _this2[ONERROR](er, entry) : _this2[UNPEND]();\n          });\n        }\n      };\n\n      stream.on('finish', function (_) {\n        // if futimes fails, try utimes\n        // if utimes fails, fail with the original error\n        // same for fchown/chown\n        var abs = entry.absolute;\n        var fd = stream.fd;\n\n        if (entry.mtime && !_this2.noMtime) {\n          actions++;\n          var atime = entry.atime || new Date();\n          var mtime = entry.mtime;\n          fs.futimes(fd, atime, mtime, function (er) {\n            return er ? fs.utimes(abs, atime, mtime, function (er2) {\n              return done(er2 && er);\n            }) : done();\n          });\n        }\n\n        if (_this2[DOCHOWN](entry)) {\n          actions++;\n\n          var uid = _this2[UID](entry);\n\n          var gid = _this2[GID](entry);\n\n          fs.fchown(fd, uid, gid, function (er) {\n            return er ? fs.chown(abs, uid, gid, function (er2) {\n              return done(er2 && er);\n            }) : done();\n          });\n        }\n\n        done();\n      });\n      var tx = this.transform ? this.transform(entry) || entry : entry;\n\n      if (tx !== entry) {\n        tx.on('error', function (er) {\n          return _this2[ONERROR](er, entry);\n        });\n        entry.pipe(tx);\n      }\n\n      tx.pipe(stream);\n    }\n  }, {\n    key: DIRECTORY,\n    value: function value(entry, fullyDone) {\n      var _this3 = this;\n\n      var mode = entry.mode & 4095 || this.dmode;\n      this[MKDIR](entry.absolute, mode, function (er) {\n        if (er) {\n          fullyDone();\n          return _this3[ONERROR](er, entry);\n        }\n\n        var actions = 1;\n\n        var done = function done(_) {\n          if (--actions === 0) {\n            fullyDone();\n\n            _this3[UNPEND]();\n\n            entry.resume();\n          }\n        };\n\n        if (entry.mtime && !_this3.noMtime) {\n          actions++;\n          fs.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done);\n        }\n\n        if (_this3[DOCHOWN](entry)) {\n          actions++;\n          fs.chown(entry.absolute, _this3[UID](entry), _this3[GID](entry), done);\n        }\n\n        done();\n      });\n    }\n  }, {\n    key: UNSUPPORTED,\n    value: function value(entry) {\n      entry.unsupported = true;\n      this.warn('TAR_ENTRY_UNSUPPORTED', \"unsupported entry type: \".concat(entry.type), {\n        entry: entry\n      });\n      entry.resume();\n    }\n  }, {\n    key: SYMLINK,\n    value: function value(entry, done) {\n      this[LINK](entry, entry.linkpath, 'symlink', done);\n    }\n  }, {\n    key: HARDLINK,\n    value: function value(entry, done) {\n      this[LINK](entry, path.resolve(this.cwd, entry.linkpath), 'link', done);\n    }\n  }, {\n    key: PEND,\n    value: function value() {\n      this[PENDING]++;\n    }\n  }, {\n    key: UNPEND,\n    value: function value() {\n      this[PENDING]--;\n      this[MAYBECLOSE]();\n    }\n  }, {\n    key: SKIP,\n    value: function value(entry) {\n      this[UNPEND]();\n      entry.resume();\n    } // Check if we can reuse an existing filesystem entry safely and\n    // overwrite it, rather than unlinking and recreating\n    // Windows doesn't report a useful nlink, so we just never reuse entries\n\n  }, {\n    key: ISREUSABLE,\n    value: function value(entry, st) {\n      return entry.type === 'File' && !this.unlink && st.isFile() && st.nlink <= 1 && process.platform !== 'win32';\n    } // check if a thing is there, and if so, try to clobber it\n\n  }, {\n    key: CHECKFS,\n    value: function value(entry) {\n      var _this4 = this;\n\n      this[PEND]();\n      var paths = [entry.path];\n      if (entry.linkpath) paths.push(entry.linkpath);\n      this.reservations.reserve(paths, function (done) {\n        return _this4[CHECKFS2](entry, done);\n      });\n    }\n  }, {\n    key: CHECKFS2,\n    value: function value(entry, done) {\n      var _this5 = this;\n\n      this[MKDIR](path.dirname(entry.absolute), this.dmode, function (er) {\n        if (er) {\n          done();\n          return _this5[ONERROR](er, entry);\n        }\n\n        fs.lstat(entry.absolute, function (er, st) {\n          if (st && (_this5.keep || _this5.newer && st.mtime > entry.mtime)) {\n            _this5[SKIP](entry);\n\n            done();\n          } else if (er || _this5[ISREUSABLE](entry, st)) _this5[MAKEFS](null, entry, done);else if (st.isDirectory()) {\n            if (entry.type === 'Directory') {\n              if (!_this5.noChmod && (!entry.mode || (st.mode & 4095) === entry.mode)) _this5[MAKEFS](null, entry, done);else {\n                fs.chmod(entry.absolute, entry.mode, function (er) {\n                  return _this5[MAKEFS](er, entry, done);\n                });\n              }\n            } else fs.rmdir(entry.absolute, function (er) {\n              return _this5[MAKEFS](er, entry, done);\n            });\n          } else unlinkFile(entry.absolute, function (er) {\n            return _this5[MAKEFS](er, entry, done);\n          });\n        });\n      });\n    }\n  }, {\n    key: MAKEFS,\n    value: function value(er, entry, done) {\n      if (er) return this[ONERROR](er, entry);\n\n      switch (entry.type) {\n        case 'File':\n        case 'OldFile':\n        case 'ContiguousFile':\n          return this[FILE](entry, done);\n\n        case 'Link':\n          return this[HARDLINK](entry, done);\n\n        case 'SymbolicLink':\n          return this[SYMLINK](entry, done);\n\n        case 'Directory':\n        case 'GNUDumpDir':\n          return this[DIRECTORY](entry, done);\n      }\n    }\n  }, {\n    key: LINK,\n    value: function value(entry, linkpath, link, done) {\n      var _this6 = this;\n\n      // XXX: get the type ('file' or 'dir') for windows\n      fs[link](linkpath, entry.absolute, function (er) {\n        if (er) return _this6[ONERROR](er, entry);\n        done();\n\n        _this6[UNPEND]();\n\n        entry.resume();\n      });\n    }\n  }]);\n\n  return Unpack;\n}(Parser);\n\nvar UnpackSync = /*#__PURE__*/function (_Unpack) {\n  _inherits(UnpackSync, _Unpack);\n\n  var _super2 = _createSuper(UnpackSync);\n\n  function UnpackSync() {\n    _classCallCheck(this, UnpackSync);\n\n    return _super2.apply(this, arguments);\n  }\n\n  _createClass(UnpackSync, [{\n    key: CHECKFS,\n    value: function value(entry) {\n      var er = this[MKDIR](path.dirname(entry.absolute), this.dmode, neverCalled);\n      if (er) return this[ONERROR](er, entry);\n\n      try {\n        var st = fs.lstatSync(entry.absolute);\n        if (this.keep || this.newer && st.mtime > entry.mtime) return this[SKIP](entry);else if (this[ISREUSABLE](entry, st)) return this[MAKEFS](null, entry, neverCalled);else {\n          try {\n            if (st.isDirectory()) {\n              if (entry.type === 'Directory') {\n                if (!this.noChmod && entry.mode && (st.mode & 4095) !== entry.mode) fs.chmodSync(entry.absolute, entry.mode);\n              } else fs.rmdirSync(entry.absolute);\n            } else unlinkFileSync(entry.absolute);\n\n            return this[MAKEFS](null, entry, neverCalled);\n          } catch (er) {\n            return this[ONERROR](er, entry);\n          }\n        }\n      } catch (er) {\n        return this[MAKEFS](null, entry, neverCalled);\n      }\n    }\n  }, {\n    key: FILE,\n    value: function value(entry, _) {\n      var _this7 = this;\n\n      var mode = entry.mode & 4095 || this.fmode;\n\n      var oner = function oner(er) {\n        var closeError;\n\n        try {\n          fs.closeSync(fd);\n        } catch (e) {\n          closeError = e;\n        }\n\n        if (er || closeError) _this7[ONERROR](er || closeError, entry);\n      };\n\n      var fd;\n\n      try {\n        fd = fs.openSync(entry.absolute, getFlag(entry.size), mode);\n      } catch (er) {\n        return oner(er);\n      }\n\n      var tx = this.transform ? this.transform(entry) || entry : entry;\n\n      if (tx !== entry) {\n        tx.on('error', function (er) {\n          return _this7[ONERROR](er, entry);\n        });\n        entry.pipe(tx);\n      }\n\n      tx.on('data', function (chunk) {\n        try {\n          fs.writeSync(fd, chunk, 0, chunk.length);\n        } catch (er) {\n          oner(er);\n        }\n      });\n      tx.on('end', function (_) {\n        var er = null; // try both, falling futimes back to utimes\n        // if either fails, handle the first error\n\n        if (entry.mtime && !_this7.noMtime) {\n          var atime = entry.atime || new Date();\n          var mtime = entry.mtime;\n\n          try {\n            fs.futimesSync(fd, atime, mtime);\n          } catch (futimeser) {\n            try {\n              fs.utimesSync(entry.absolute, atime, mtime);\n            } catch (utimeser) {\n              er = futimeser;\n            }\n          }\n        }\n\n        if (_this7[DOCHOWN](entry)) {\n          var uid = _this7[UID](entry);\n\n          var gid = _this7[GID](entry);\n\n          try {\n            fs.fchownSync(fd, uid, gid);\n          } catch (fchowner) {\n            try {\n              fs.chownSync(entry.absolute, uid, gid);\n            } catch (chowner) {\n              er = er || fchowner;\n            }\n          }\n        }\n\n        oner(er);\n      });\n    }\n  }, {\n    key: DIRECTORY,\n    value: function value(entry, _) {\n      var mode = entry.mode & 4095 || this.dmode;\n      var er = this[MKDIR](entry.absolute, mode);\n      if (er) return this[ONERROR](er, entry);\n\n      if (entry.mtime && !this.noMtime) {\n        try {\n          fs.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime);\n        } catch (er) {}\n      }\n\n      if (this[DOCHOWN](entry)) {\n        try {\n          fs.chownSync(entry.absolute, this[UID](entry), this[GID](entry));\n        } catch (er) {}\n      }\n\n      entry.resume();\n    }\n  }, {\n    key: MKDIR,\n    value: function value(dir, mode) {\n      try {\n        return mkdir.sync(dir, {\n          uid: this.uid,\n          gid: this.gid,\n          processUid: this.processUid,\n          processGid: this.processGid,\n          umask: this.processUmask,\n          preserve: this.preservePaths,\n          unlink: this.unlink,\n          cache: this.dirCache,\n          cwd: this.cwd,\n          mode: mode\n        });\n      } catch (er) {\n        return er;\n      }\n    }\n  }, {\n    key: LINK,\n    value: function value(entry, linkpath, link, _) {\n      try {\n        fs[link + 'Sync'](linkpath, entry.absolute);\n        entry.resume();\n      } catch (er) {\n        return this[ONERROR](er, entry);\n      }\n    }\n  }]);\n\n  return UnpackSync;\n}(Unpack);\n\nUnpack.Sync = UnpackSync;\nmodule.exports = Unpack;","map":{"version":3,"sources":["/Users/austenhughes/The-Baffoonery/node_modules/tar/lib/unpack.js"],"names":["assert","require","Parser","fs","fsm","path","mkdir","wc","pathReservations","ONENTRY","Symbol","CHECKFS","CHECKFS2","ISREUSABLE","MAKEFS","FILE","DIRECTORY","LINK","SYMLINK","HARDLINK","UNSUPPORTED","CHECKPATH","MKDIR","ONERROR","PENDING","PEND","UNPEND","ENDED","MAYBECLOSE","SKIP","DOCHOWN","UID","GID","crypto","getFlag","neverCalled","Error","unlinkFile","cb","process","platform","unlink","name","randomBytes","toString","rename","er","unlinkFileSync","unlinkSync","renameSync","uint32","a","b","c","Unpack","opt","ondone","_","reservations","transform","writable","readable","dirCache","Map","uid","gid","TypeError","preserveOwner","setOwner","undefined","getuid","processUid","processGid","getgid","forceChown","win32","newer","keep","noMtime","preservePaths","cwd","resolve","strip","processUmask","noChmod","umask","dmode","fmode","on","entry","code","msg","data","recoverable","emit","parts","split","length","slice","join","type","linkparts","linkpath","p","match","warn","isAbsolute","parsed","parse","substr","root","r","encode","absolute","resume","equal","mode","dir","preserve","cache","fullyDone","stream","WriteStream","flags","size","autoClose","actions","done","close","fd","abs","mtime","atime","Date","futimes","utimes","er2","fchown","chown","tx","pipe","unsupported","st","isFile","nlink","paths","push","reserve","dirname","lstat","isDirectory","chmod","rmdir","link","UnpackSync","lstatSync","chmodSync","rmdirSync","oner","closeError","closeSync","e","openSync","chunk","writeSync","futimesSync","futimeser","utimesSync","utimeser","fchownSync","fchowner","chownSync","chowner","sync","Sync","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\n// the PEND/UNPEND stuff tracks whether we're ready to emit end/close yet.\n// but the path reservations are required to avoid race conditions where\n// parallelized unpack ops may mess with one another, due to dependencies\n// (like a Link depending on its target) or destructive operations (like\n// clobbering an fs object to create one of a different type.)\n\nconst assert = require('assert')\nconst Parser = require('./parse.js')\nconst fs = require('fs')\nconst fsm = require('fs-minipass')\nconst path = require('path')\nconst mkdir = require('./mkdir.js')\nconst wc = require('./winchars.js')\nconst pathReservations = require('./path-reservations.js')\n\nconst ONENTRY = Symbol('onEntry')\nconst CHECKFS = Symbol('checkFs')\nconst CHECKFS2 = Symbol('checkFs2')\nconst ISREUSABLE = Symbol('isReusable')\nconst MAKEFS = Symbol('makeFs')\nconst FILE = Symbol('file')\nconst DIRECTORY = Symbol('directory')\nconst LINK = Symbol('link')\nconst SYMLINK = Symbol('symlink')\nconst HARDLINK = Symbol('hardlink')\nconst UNSUPPORTED = Symbol('unsupported')\nconst CHECKPATH = Symbol('checkPath')\nconst MKDIR = Symbol('mkdir')\nconst ONERROR = Symbol('onError')\nconst PENDING = Symbol('pending')\nconst PEND = Symbol('pend')\nconst UNPEND = Symbol('unpend')\nconst ENDED = Symbol('ended')\nconst MAYBECLOSE = Symbol('maybeClose')\nconst SKIP = Symbol('skip')\nconst DOCHOWN = Symbol('doChown')\nconst UID = Symbol('uid')\nconst GID = Symbol('gid')\nconst crypto = require('crypto')\nconst getFlag = require('./get-write-flag.js')\n\n/* istanbul ignore next */\nconst neverCalled = () => {\n  throw new Error('sync function called cb somehow?!?')\n}\n\n// Unlinks on Windows are not atomic.\n//\n// This means that if you have a file entry, followed by another\n// file entry with an identical name, and you cannot re-use the file\n// (because it's a hardlink, or because unlink:true is set, or it's\n// Windows, which does not have useful nlink values), then the unlink\n// will be committed to the disk AFTER the new file has been written\n// over the old one, deleting the new file.\n//\n// To work around this, on Windows systems, we rename the file and then\n// delete the renamed file.  It's a sloppy kludge, but frankly, I do not\n// know of a better way to do this, given windows' non-atomic unlink\n// semantics.\n//\n// See: https://github.com/npm/node-tar/issues/183\n/* istanbul ignore next */\nconst unlinkFile = (path, cb) => {\n  if (process.platform !== 'win32')\n    return fs.unlink(path, cb)\n\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')\n  fs.rename(path, name, er => {\n    if (er)\n      return cb(er)\n    fs.unlink(name, cb)\n  })\n}\n\n/* istanbul ignore next */\nconst unlinkFileSync = path => {\n  if (process.platform !== 'win32')\n    return fs.unlinkSync(path)\n\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')\n  fs.renameSync(path, name)\n  fs.unlinkSync(name)\n}\n\n// this.gid, entry.gid, this.processUid\nconst uint32 = (a, b, c) =>\n  a === a >>> 0 ? a\n  : b === b >>> 0 ? b\n  : c\n\nclass Unpack extends Parser {\n  constructor (opt) {\n    if (!opt)\n      opt = {}\n\n    opt.ondone = _ => {\n      this[ENDED] = true\n      this[MAYBECLOSE]()\n    }\n\n    super(opt)\n\n    this.reservations = pathReservations()\n\n    this.transform = typeof opt.transform === 'function' ? opt.transform : null\n\n    this.writable = true\n    this.readable = false\n\n    this[PENDING] = 0\n    this[ENDED] = false\n\n    this.dirCache = opt.dirCache || new Map()\n\n    if (typeof opt.uid === 'number' || typeof opt.gid === 'number') {\n      // need both or neither\n      if (typeof opt.uid !== 'number' || typeof opt.gid !== 'number')\n        throw new TypeError('cannot set owner without number uid and gid')\n      if (opt.preserveOwner) {\n        throw new TypeError(\n          'cannot preserve owner in archive and also set owner explicitly')\n      }\n      this.uid = opt.uid\n      this.gid = opt.gid\n      this.setOwner = true\n    } else {\n      this.uid = null\n      this.gid = null\n      this.setOwner = false\n    }\n\n    // default true for root\n    if (opt.preserveOwner === undefined && typeof opt.uid !== 'number')\n      this.preserveOwner = process.getuid && process.getuid() === 0\n    else\n      this.preserveOwner = !!opt.preserveOwner\n\n    this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ?\n      process.getuid() : null\n    this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ?\n      process.getgid() : null\n\n    // mostly just for testing, but useful in some cases.\n    // Forcibly trigger a chown on every entry, no matter what\n    this.forceChown = opt.forceChown === true\n\n    // turn ><?| in filenames into 0xf000-higher encoded forms\n    this.win32 = !!opt.win32 || process.platform === 'win32'\n\n    // do not unpack over files that are newer than what's in the archive\n    this.newer = !!opt.newer\n\n    // do not unpack over ANY files\n    this.keep = !!opt.keep\n\n    // do not set mtime/atime of extracted entries\n    this.noMtime = !!opt.noMtime\n\n    // allow .., absolute path entries, and unpacking through symlinks\n    // without this, warn and skip .., relativize absolutes, and error\n    // on symlinks in extraction path\n    this.preservePaths = !!opt.preservePaths\n\n    // unlink files and links before writing. This breaks existing hard\n    // links, and removes symlink directories rather than erroring\n    this.unlink = !!opt.unlink\n\n    this.cwd = path.resolve(opt.cwd || process.cwd())\n    this.strip = +opt.strip || 0\n    // if we're not chmodding, then we don't need the process umask\n    this.processUmask = opt.noChmod ? 0 : process.umask()\n    this.umask = typeof opt.umask === 'number' ? opt.umask : this.processUmask\n\n    // default mode for dirs created as parents\n    this.dmode = opt.dmode || (0o0777 & (~this.umask))\n    this.fmode = opt.fmode || (0o0666 & (~this.umask))\n\n    this.on('entry', entry => this[ONENTRY](entry))\n  }\n\n  // a bad or damaged archive is a warning for Parser, but an error\n  // when extracting.  Mark those errors as unrecoverable, because\n  // the Unpack contract cannot be met.\n  warn (code, msg, data = {}) {\n    if (code === 'TAR_BAD_ARCHIVE' || code === 'TAR_ABORT')\n      data.recoverable = false\n    return super.warn(code, msg, data)\n  }\n\n  [MAYBECLOSE] () {\n    if (this[ENDED] && this[PENDING] === 0) {\n      this.emit('prefinish')\n      this.emit('finish')\n      this.emit('end')\n      this.emit('close')\n    }\n  }\n\n  [CHECKPATH] (entry) {\n    if (this.strip) {\n      const parts = entry.path.split(/\\/|\\\\/)\n      if (parts.length < this.strip)\n        return false\n      entry.path = parts.slice(this.strip).join('/')\n\n      if (entry.type === 'Link') {\n        const linkparts = entry.linkpath.split(/\\/|\\\\/)\n        if (linkparts.length >= this.strip)\n          entry.linkpath = linkparts.slice(this.strip).join('/')\n      }\n    }\n\n    if (!this.preservePaths) {\n      const p = entry.path\n      if (p.match(/(^|\\/|\\\\)\\.\\.(\\\\|\\/|$)/)) {\n        this.warn('TAR_ENTRY_ERROR', `path contains '..'`, {\n          entry,\n          path: p,\n        })\n        return false\n      }\n\n      // absolutes on posix are also absolutes on win32\n      // so we only need to test this one to get both\n      if (path.win32.isAbsolute(p)) {\n        const parsed = path.win32.parse(p)\n        entry.path = p.substr(parsed.root.length)\n        const r = parsed.root\n        this.warn('TAR_ENTRY_INFO', `stripping ${r} from absolute path`, {\n          entry,\n          path: p,\n        })\n      }\n    }\n\n    // only encode : chars that aren't drive letter indicators\n    if (this.win32) {\n      const parsed = path.win32.parse(entry.path)\n      entry.path = parsed.root === '' ? wc.encode(entry.path)\n        : parsed.root + wc.encode(entry.path.substr(parsed.root.length))\n    }\n\n    if (path.isAbsolute(entry.path))\n      entry.absolute = entry.path\n    else\n      entry.absolute = path.resolve(this.cwd, entry.path)\n\n    return true\n  }\n\n  [ONENTRY] (entry) {\n    if (!this[CHECKPATH](entry))\n      return entry.resume()\n\n    assert.equal(typeof entry.absolute, 'string')\n\n    switch (entry.type) {\n      case 'Directory':\n      case 'GNUDumpDir':\n        if (entry.mode)\n          entry.mode = entry.mode | 0o700\n\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n      case 'Link':\n      case 'SymbolicLink':\n        return this[CHECKFS](entry)\n\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'FIFO':\n      default:\n        return this[UNSUPPORTED](entry)\n    }\n  }\n\n  [ONERROR] (er, entry) {\n    // Cwd has to exist, or else nothing works. That's serious.\n    // Other errors are warnings, which raise the error in strict\n    // mode, but otherwise continue on.\n    if (er.name === 'CwdError')\n      this.emit('error', er)\n    else {\n      this.warn('TAR_ENTRY_ERROR', er, {entry})\n      this[UNPEND]()\n      entry.resume()\n    }\n  }\n\n  [MKDIR] (dir, mode, cb) {\n    mkdir(dir, {\n      uid: this.uid,\n      gid: this.gid,\n      processUid: this.processUid,\n      processGid: this.processGid,\n      umask: this.processUmask,\n      preserve: this.preservePaths,\n      unlink: this.unlink,\n      cache: this.dirCache,\n      cwd: this.cwd,\n      mode: mode,\n      noChmod: this.noChmod,\n    }, cb)\n  }\n\n  [DOCHOWN] (entry) {\n    // in preserve owner mode, chown if the entry doesn't match process\n    // in set owner mode, chown if setting doesn't match process\n    return this.forceChown ||\n      this.preserveOwner &&\n      (typeof entry.uid === 'number' && entry.uid !== this.processUid ||\n        typeof entry.gid === 'number' && entry.gid !== this.processGid)\n      ||\n      (typeof this.uid === 'number' && this.uid !== this.processUid ||\n        typeof this.gid === 'number' && this.gid !== this.processGid)\n  }\n\n  [UID] (entry) {\n    return uint32(this.uid, entry.uid, this.processUid)\n  }\n\n  [GID] (entry) {\n    return uint32(this.gid, entry.gid, this.processGid)\n  }\n\n  [FILE] (entry, fullyDone) {\n    const mode = entry.mode & 0o7777 || this.fmode\n    const stream = new fsm.WriteStream(entry.absolute, {\n      flags: getFlag(entry.size),\n      mode: mode,\n      autoClose: false,\n    })\n    stream.on('error', er => this[ONERROR](er, entry))\n\n    let actions = 1\n    const done = er => {\n      if (er)\n        return this[ONERROR](er, entry)\n\n      if (--actions === 0) {\n        fs.close(stream.fd, er => {\n          fullyDone()\n          er ? this[ONERROR](er, entry) : this[UNPEND]()\n        })\n      }\n    }\n\n    stream.on('finish', _ => {\n      // if futimes fails, try utimes\n      // if utimes fails, fail with the original error\n      // same for fchown/chown\n      const abs = entry.absolute\n      const fd = stream.fd\n\n      if (entry.mtime && !this.noMtime) {\n        actions++\n        const atime = entry.atime || new Date()\n        const mtime = entry.mtime\n        fs.futimes(fd, atime, mtime, er =>\n          er ? fs.utimes(abs, atime, mtime, er2 => done(er2 && er))\n          : done())\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++\n        const uid = this[UID](entry)\n        const gid = this[GID](entry)\n        fs.fchown(fd, uid, gid, er =>\n          er ? fs.chown(abs, uid, gid, er2 => done(er2 && er))\n          : done())\n      }\n\n      done()\n    })\n\n    const tx = this.transform ? this.transform(entry) || entry : entry\n    if (tx !== entry) {\n      tx.on('error', er => this[ONERROR](er, entry))\n      entry.pipe(tx)\n    }\n    tx.pipe(stream)\n  }\n\n  [DIRECTORY] (entry, fullyDone) {\n    const mode = entry.mode & 0o7777 || this.dmode\n    this[MKDIR](entry.absolute, mode, er => {\n      if (er) {\n        fullyDone()\n        return this[ONERROR](er, entry)\n      }\n\n      let actions = 1\n      const done = _ => {\n        if (--actions === 0) {\n          fullyDone()\n          this[UNPEND]()\n          entry.resume()\n        }\n      }\n\n      if (entry.mtime && !this.noMtime) {\n        actions++\n        fs.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done)\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++\n        fs.chown(entry.absolute, this[UID](entry), this[GID](entry), done)\n      }\n\n      done()\n    })\n  }\n\n  [UNSUPPORTED] (entry) {\n    entry.unsupported = true\n    this.warn('TAR_ENTRY_UNSUPPORTED',\n      `unsupported entry type: ${entry.type}`, {entry})\n    entry.resume()\n  }\n\n  [SYMLINK] (entry, done) {\n    this[LINK](entry, entry.linkpath, 'symlink', done)\n  }\n\n  [HARDLINK] (entry, done) {\n    this[LINK](entry, path.resolve(this.cwd, entry.linkpath), 'link', done)\n  }\n\n  [PEND] () {\n    this[PENDING]++\n  }\n\n  [UNPEND] () {\n    this[PENDING]--\n    this[MAYBECLOSE]()\n  }\n\n  [SKIP] (entry) {\n    this[UNPEND]()\n    entry.resume()\n  }\n\n  // Check if we can reuse an existing filesystem entry safely and\n  // overwrite it, rather than unlinking and recreating\n  // Windows doesn't report a useful nlink, so we just never reuse entries\n  [ISREUSABLE] (entry, st) {\n    return entry.type === 'File' &&\n      !this.unlink &&\n      st.isFile() &&\n      st.nlink <= 1 &&\n      process.platform !== 'win32'\n  }\n\n  // check if a thing is there, and if so, try to clobber it\n  [CHECKFS] (entry) {\n    this[PEND]()\n    const paths = [entry.path]\n    if (entry.linkpath)\n      paths.push(entry.linkpath)\n    this.reservations.reserve(paths, done => this[CHECKFS2](entry, done))\n  }\n\n  [CHECKFS2] (entry, done) {\n    this[MKDIR](path.dirname(entry.absolute), this.dmode, er => {\n      if (er) {\n        done()\n        return this[ONERROR](er, entry)\n      }\n      fs.lstat(entry.absolute, (er, st) => {\n        if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {\n          this[SKIP](entry)\n          done()\n        } else if (er || this[ISREUSABLE](entry, st))\n          this[MAKEFS](null, entry, done)\n\n        else if (st.isDirectory()) {\n          if (entry.type === 'Directory') {\n            if (!this.noChmod && (!entry.mode || (st.mode & 0o7777) === entry.mode))\n              this[MAKEFS](null, entry, done)\n            else {\n              fs.chmod(entry.absolute, entry.mode,\n                er => this[MAKEFS](er, entry, done))\n            }\n          } else\n            fs.rmdir(entry.absolute, er => this[MAKEFS](er, entry, done))\n        } else\n          unlinkFile(entry.absolute, er => this[MAKEFS](er, entry, done))\n      })\n    })\n  }\n\n  [MAKEFS] (er, entry, done) {\n    if (er)\n      return this[ONERROR](er, entry)\n\n    switch (entry.type) {\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n        return this[FILE](entry, done)\n\n      case 'Link':\n        return this[HARDLINK](entry, done)\n\n      case 'SymbolicLink':\n        return this[SYMLINK](entry, done)\n\n      case 'Directory':\n      case 'GNUDumpDir':\n        return this[DIRECTORY](entry, done)\n    }\n  }\n\n  [LINK] (entry, linkpath, link, done) {\n    // XXX: get the type ('file' or 'dir') for windows\n    fs[link](linkpath, entry.absolute, er => {\n      if (er)\n        return this[ONERROR](er, entry)\n      done()\n      this[UNPEND]()\n      entry.resume()\n    })\n  }\n}\n\nclass UnpackSync extends Unpack {\n  [CHECKFS] (entry) {\n    const er = this[MKDIR](path.dirname(entry.absolute), this.dmode, neverCalled)\n    if (er)\n      return this[ONERROR](er, entry)\n    try {\n      const st = fs.lstatSync(entry.absolute)\n      if (this.keep || this.newer && st.mtime > entry.mtime)\n        return this[SKIP](entry)\n      else if (this[ISREUSABLE](entry, st))\n        return this[MAKEFS](null, entry, neverCalled)\n      else {\n        try {\n          if (st.isDirectory()) {\n            if (entry.type === 'Directory') {\n              if (!this.noChmod && entry.mode && (st.mode & 0o7777) !== entry.mode)\n                fs.chmodSync(entry.absolute, entry.mode)\n            } else\n              fs.rmdirSync(entry.absolute)\n          } else\n            unlinkFileSync(entry.absolute)\n          return this[MAKEFS](null, entry, neverCalled)\n        } catch (er) {\n          return this[ONERROR](er, entry)\n        }\n      }\n    } catch (er) {\n      return this[MAKEFS](null, entry, neverCalled)\n    }\n  }\n\n  [FILE] (entry, _) {\n    const mode = entry.mode & 0o7777 || this.fmode\n\n    const oner = er => {\n      let closeError\n      try {\n        fs.closeSync(fd)\n      } catch (e) {\n        closeError = e\n      }\n      if (er || closeError)\n        this[ONERROR](er || closeError, entry)\n    }\n\n    let fd\n    try {\n      fd = fs.openSync(entry.absolute, getFlag(entry.size), mode)\n    } catch (er) {\n      return oner(er)\n    }\n    const tx = this.transform ? this.transform(entry) || entry : entry\n    if (tx !== entry) {\n      tx.on('error', er => this[ONERROR](er, entry))\n      entry.pipe(tx)\n    }\n\n    tx.on('data', chunk => {\n      try {\n        fs.writeSync(fd, chunk, 0, chunk.length)\n      } catch (er) {\n        oner(er)\n      }\n    })\n\n    tx.on('end', _ => {\n      let er = null\n      // try both, falling futimes back to utimes\n      // if either fails, handle the first error\n      if (entry.mtime && !this.noMtime) {\n        const atime = entry.atime || new Date()\n        const mtime = entry.mtime\n        try {\n          fs.futimesSync(fd, atime, mtime)\n        } catch (futimeser) {\n          try {\n            fs.utimesSync(entry.absolute, atime, mtime)\n          } catch (utimeser) {\n            er = futimeser\n          }\n        }\n      }\n\n      if (this[DOCHOWN](entry)) {\n        const uid = this[UID](entry)\n        const gid = this[GID](entry)\n\n        try {\n          fs.fchownSync(fd, uid, gid)\n        } catch (fchowner) {\n          try {\n            fs.chownSync(entry.absolute, uid, gid)\n          } catch (chowner) {\n            er = er || fchowner\n          }\n        }\n      }\n\n      oner(er)\n    })\n  }\n\n  [DIRECTORY] (entry, _) {\n    const mode = entry.mode & 0o7777 || this.dmode\n    const er = this[MKDIR](entry.absolute, mode)\n    if (er)\n      return this[ONERROR](er, entry)\n    if (entry.mtime && !this.noMtime) {\n      try {\n        fs.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime)\n      } catch (er) {}\n    }\n    if (this[DOCHOWN](entry)) {\n      try {\n        fs.chownSync(entry.absolute, this[UID](entry), this[GID](entry))\n      } catch (er) {}\n    }\n    entry.resume()\n  }\n\n  [MKDIR] (dir, mode) {\n    try {\n      return mkdir.sync(dir, {\n        uid: this.uid,\n        gid: this.gid,\n        processUid: this.processUid,\n        processGid: this.processGid,\n        umask: this.processUmask,\n        preserve: this.preservePaths,\n        unlink: this.unlink,\n        cache: this.dirCache,\n        cwd: this.cwd,\n        mode: mode,\n      })\n    } catch (er) {\n      return er\n    }\n  }\n\n  [LINK] (entry, linkpath, link, _) {\n    try {\n      fs[link + 'Sync'](linkpath, entry.absolute)\n      entry.resume()\n    } catch (er) {\n      return this[ONERROR](er, entry)\n    }\n  }\n}\n\nUnpack.Sync = UnpackSync\nmodule.exports = Unpack\n"]},"metadata":{},"sourceType":"script"}